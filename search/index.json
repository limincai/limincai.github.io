[{"content":"文档参考：Redis 官方文档\nSpringBoot 项目连接 Redis 依赖引入 在 Springboot 项目中，添加如下依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- Redis 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Json 序列化依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jsr310\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.13.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置 Redis 新建一个 RedisConfig 类用于 Redis 的配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Redis 配置类 * * @author limincai */ @Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory connection) { RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate = new RedisTemplate\u0026lt;\u0026gt;(); redisTemplate.setConnectionFactory(connection); // 设置键序列化器为 StringRedisSerializer，所有的键会被序列化为字符串 redisTemplate.setKeySerializer(new StringRedisSerializer()); // 设置值序列化器为 GenericJackson2JsonRedisSerializer，所有的键会被序列化为 Json redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; } } 配置 application.yaml 1 2 3 4 5 6 7 8 9 10 11 12 spring: redis: host: localhost # Redis服务器的主机名，默认 localhost port: 6379 # Redis服务器的端口号，默认 6379 password: # Redis服务器的密码，如果没有密码则留空，默认为空 timeout: 3000 # 连接超时时间（单位：毫秒） lettuce: pool: max-active: 8 # 最大连接数 max-wait: -1 # 最大等待时间，-1表示不限制 max-idle: 8 # 最大空闲连接数 min-idle: 1 # 最小空闲连接数 基本数据结构 String String 是 Redis 中最简单常用的数据类型，可以存储任何类型的数据比如字符串、整形、浮点、序列化后的对象等。\n应用场景 缓存：可以作为缓存数据库使用，提高系统性能，减少对数据库访问的压力。 会话：可以存储 seesion、token，等会话数据，可以用在分布式系统中。 计数器：Redis 的 incr/decr 命令可以用于实现计数器功能。可以将计数器存储为 String 类型，每次更新时通过 incr/decr 命令进行自增或自减操作。 分布式锁：通过 SETNX 命令可以实现一个具有过期时间的分布式锁。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 设置指定 key 值。 SET key value # 获取指定 key 值。 GET key # 判断 key 是否存在。 EXSITS key # 删除 key DEL key # 批量设置 key 值 MSET key1 value1 [key2 value2 ...] # 批量删除 key 值 MGET key1 [ key2 ...] # 将 key 中存储的数值加1。 INCR key # 将 key 中存储的数值减1。 DECR key # 给 key 设置过期时间。 EXPIRE key seconds # 设置 key 值并设置过期时间，如果 key 存在不做任何操作并返回0，否则返回1。 SETNX key value [EX seconds | PX milliseconds] # 查看剩余过期时间。 TTL key Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Test void testString() { // 设置指定 key 值 redisTemplate.opsForValue().set(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;); // 获取指定 key 值 System.out.println(redisTemplate.opsForValue().get(\u0026#34;string1\u0026#34;)); // 判断 key 是否存在 System.out.println(redisTemplate.opsForValue().getOperations().hasKey(\u0026#34;string1\u0026#34;)); // 得到值后删除 key System.out.println(redisTemplate.opsForValue().getAndDelete(\u0026#34;string1\u0026#34;)); // 批量设置 key 值 HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;); map.put(\u0026#34;string2\u0026#34;, \u0026#34;value2\u0026#34;); redisTemplate.opsForValue().multiSet(map); // 批量删除 key 值 HashSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(\u0026#34;string1\u0026#34;); set.add(\u0026#34;string2\u0026#34;); redisTemplate.opsForValue().getOperations().delete(set); // 将 key 中存储的数值加1并返回修改后的值 redisTemplate.opsForValue().set(\u0026#34;num1\u0026#34;, 1); System.out.println(redisTemplate.opsForValue().increment(\u0026#34;num1\u0026#34;)); // 将 key 中存储的数值减1并返回修改后的值 System.out.println(redisTemplate.opsForValue().decrement(\u0026#34;value1\u0026#34;)); // 给 key 设置过期时间 redisTemplate.opsForValue().set(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;); redisTemplate.opsForValue().getAndExpire(\u0026#34;string1\u0026#34;, 1000, TimeUnit.SECONDS); // 设置 key 值并设置过期时间，如果 key 存在不做任何操作并返回 false，否则返回 true System.out.println(redisTemplate.opsForValue().setIfAbsent(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;)); System.out.println(redisTemplate.opsForValue().setIfAbsent(\u0026#34;string2\u0026#34;, \u0026#34;value2\u0026#34;, 1000, TimeUnit.SECONDS)); // 查看剩余过期时间 System.out.println(redisTemplate.opsForValue().getOperations().getExpire(\u0026#34;string2\u0026#34;)); } List List 是简单的字符串列表，按照插入顺序排序。\n应用场景 最消息排行榜：可以使用 Redis 列表来存储最新的消息。每次有新的消息到达时，将其插入到列表的头，当列表的长度超过一定限制时，可以使用LTRIM命令进行修剪，以保持列表的长度。 实时消息记录：可以使用 Redis 列表来保存实时产生的消息记录。每当有新的消息产生时，将其插入到列表头部，以便可以追溯最近的一定数量的消息记录。 排行榜/计分系统：可以使用 Redis 列表来实现排行榜或计分系统。每个元素可以包含一个分数，通过对元按照分数进行排序，可以获取到排行榜中的前几名或指定范围内的元素。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 将一个或多个值插入到列表的左侧，返回插入后列表的长度。 LPUSH key value [value ...] # 将一个或多个值插入到列表的右侧，返回插入后列表的长度。 RPUSH key value [value ...] #移除返回列表的左侧第一个元素。 LPOP key # 移除并返回列表的右侧第一个元素。 RPOP key # 返回列表的长度。 LLEN key # 获取列表中指定范围内的元素。 LRANGE key start stop # 返回列表中指定索引位置的元素。 LINDEX key index # 设置列表中指定索引位置的元素的值。 LSET key index value # 移除列表中的指定元素。 LREM key count value # 修剪列表，只保留指定范围内的元素。 LTRIM key start stop Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Test void testList() { // 将一个或多个值插入到列表的左侧，返回插入后列表的长度。 redisTemplate.opsForList().leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;, \u0026#34;value3\u0026#34;); // 将一个或多个值插入到列表的右侧，返回插入后列表的长度。 redisTemplate.opsForList().rightPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;value4\u0026#34;, \u0026#34;value5\u0026#34;, \u0026#34;value6\u0026#34;); // 移除返回列表的左侧第一个元素。 System.out.println(redisTemplate.opsForList().leftPop(\u0026#34;mylist\u0026#34;)); // 移除并返回列表的右侧第一个元素。 System.out.println(redisTemplate.opsForList().rightPop(\u0026#34;mylist\u0026#34;)); // 返回列表的长度。 System.out.println(redisTemplate.opsForList().size(\u0026#34;mylist\u0026#34;)); // 获取列表中指定范围内的元素。 System.out.println(redisTemplate.opsForList().range(\u0026#34;mylist\u0026#34;, 2, 3)); // 返回列表中指定索引位置的元素。 System.out.println(redisTemplate.opsForList().index(\u0026#34;mylist\u0026#34;, 3)); // 设置列表中指定索引位置的元素的值。 redisTemplate.opsForList().set(\u0026#34;mylist\u0026#34;, 2, \u0026#34;value3\u0026#34;); // 移除列表中的指定元素。 redisTemplate.opsForList().remove(\u0026#34;mylist\u0026#34;, 1, \u0026#34;value1\u0026#34;); // 修剪列表，只保留指定范围内的元素。 redisTemplate.opsForList().trim(\u0026#34;mylist\u0026#34;, 1, 3); } Hash Hash 是一个 String 类型的键值对。\n应用场景 缓存对象：可以将对象的字段和属性存储在Redis的Hash中，以便快速地读取和更新。例如，用户信息存储在一个Hash中，每个用户的字段可以是用户ID、用户名、年龄等。这样，在需要读取或用户信息时，可以直接通过用户ID来获取或更新相应的字段。 计数器：可以使用Hash来实现计数器功能。通过将计数器的名称作为Hash的键名，将计数值作为键值存储在Hash中。然后可以使用Redis提供的原子操作对计数器进行增减操作，如HINCRBY命令。 实时排行榜：可以使用Hash来实现实时排行榜功能。将用户ID作为Hash的键名，将用户的分数作为键值存储在Hash中。通过更新用户的分数来实现排行榜实时更新，并使用Redis提供的ZSET数据结构进行排名的计算。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 设置 Hash 中指定字段的值。 HSET key field1 value1 [field2 value2...] # 获取 Hash 中指定字段的值 HGET key field # 设置 Hash 中多个字段的值。 HMSET key field1 value1 [field2 value2...] # 获取 Hash 中多个字段的值。 HMGET key field1 [field2...] # 获取 Hash 中所有字段和值。 HGETALL key # 删除 Hash 中的指定字段。 HDEL key field # 判断 Hash 中是否存在指定字段。 HEXISTS key field # 获取 Hash 中所有值 HVALS key Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Test void testHash() { // 设置 Hash 中指定字段的值。 redisTemplate.opsForHash().put(\u0026#34;myhash\u0026#34;, \u0026#34;field1\u0026#34;, \u0026#34;value1\u0026#34;); // 获取 Hash 中指定字段的值 System.out.println(redisTemplate.opsForHash().get(\u0026#34;myhash\u0026#34;, \u0026#34;field1\u0026#34;)); // 设置 Hash 中多个字段的值。 HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;field2\u0026#34;, \u0026#34;value2\u0026#34;); map.put(\u0026#34;field3\u0026#34;, \u0026#34;value3\u0026#34;); redisTemplate.opsForHash().putAll(\u0026#34;myhash\u0026#34;, map); // 获取 Hash 中多个字段的值。 HashSet\u0026lt;Object\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(\u0026#34;field1\u0026#34;); set.add(\u0026#34;field2\u0026#34;); System.out.println(redisTemplate.opsForHash().multiGet(\u0026#34;myhash\u0026#34;, set)); // 获取 Hash 中所有字段和值。 System.out.println(redisTemplate.opsForHash().entries(\u0026#34;myhash\u0026#34;)); // 删除 Hash 中的指定字段。 redisTemplate.opsForHash().delete(\u0026#34;myhash\u0026#34;, \u0026#34;field1\u0026#34;); // 判断 Hash 中是否存在指定字段。 System.out.println(redisTemplate.opsForHash().hasKey(\u0026#34;myhash\u0026#34;,\u0026#34;field2\u0026#34;)); // 获取 Hash 中所有值 System.out.println(redisTemplate.opsForHash().values(\u0026#34;myhash\u0026#34;)); } Set Set 是一种无序集合，集合中的元素唯一，类似于 Java 中的 HashSet\n应用场景 抽奖和排行榜：Set可以用于实现抽奖功能和排行榜功能。例如，抽奖活动的参与者可以存储在Set，每次抽奖时从Set中随机选择一个用户；另外，将用户的得分、点击量或其他指标存储在Set中，可以据权重排序来生成排行榜。 好友关系：Set可以用于存储用户的好友关系。例如，每个用户对应一个Set，保存了该用户的好友列表，可以方便地进行好友操作，如查找共同的好友、计算好友数等。 集成员查找：Redis的Set数据结构可以高效地进行成员的查找操作。例如，可以用于实现黑白名单的判断，快速判断某个元素是否在集合中。 点赞、收藏等功能：可以使用Set来存储用户对某个实体（如文章、评论、商品等）的点赞、收藏关系。个实体的点赞、收藏用户就是一个Set。通过Set提供的添加、删除、计数等操作，可以方便地管理点赞、收藏关系。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 向 Set 中添加一个或多个元素。 SADD key value1 [value2...] # 从 Set 删除一个或多个元素。 SREM key value1 [value2...] # 判断一个元素是否存在于 Set 中。 SISMEMBER key value # 获取 Set 中的所有元素。 SMEMBERS myset # 获取集合的成员数 SCARD key # 移除并返回 Set 中的一个随机元素 SPOP key # 返回所有 Set 的交集 SINTER key1 [key2...] # 返回所有 Set 的并集 SUNION key1 [key2...] # 返回所有 Set 的差集 SDIFF key1 [key2...] Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Test void testSet() { // 向 Set 中添加一个或多个元素。 redisTemplate.opsForSet().add(\u0026#34;myset\u0026#34;, \u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;, \u0026#34;value3\u0026#34;, \u0026#34;value4\u0026#34;); redisTemplate.opsForSet().add(\u0026#34;myset1\u0026#34;, \u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;, \u0026#34;value6\u0026#34;, \u0026#34;value5\u0026#34;); // 从 Set 删除一个或多个元素。 redisTemplate.opsForSet().remove(\u0026#34;myset\u0026#34;, \u0026#34;value3\u0026#34;, \u0026#34;value4\u0026#34;); // 判断一个元素是否存在于 Set 中。 System.out.println(redisTemplate.opsForSet().isMember(\u0026#34;myset\u0026#34;, \u0026#34;value1\u0026#34;)); // 获取 Set 中的所有元素。 System.out.println(redisTemplate.opsForSet().members(\u0026#34;myset\u0026#34;)); // 获取集合的成员数 System.out.println(redisTemplate.opsForSet().size(\u0026#34;myset\u0026#34;)); // 移除并返回 Set 中的一个随机元素 System.out.println(redisTemplate.opsForSet().pop(\u0026#34;myset\u0026#34;)); // 返回所有 Set 的交集 System.out.println(redisTemplate.opsForSet().intersect(\u0026#34;myset\u0026#34;, \u0026#34;myset1\u0026#34;)); // 返回所有 Set 的并集 System.out.println(redisTemplate.opsForSet().union(\u0026#34;myset\u0026#34;, \u0026#34;myset1\u0026#34;)); // 返回所有 Set 的差集 System.out.println(redisTemplate.opsForSet().difference(\u0026#34;myset\u0026#34;, \u0026#34;myset1\u0026#34;)); } Sorted Set Sorted Set 类似于 Set，但和 Set 相比，维护了一个 double 类型的分数，使得集合中的元素能够按分数排列。\n应用场景 排行榜：可以使用Sorted Set来存储用户的得分或其他评分指标，并按照分数进行排序，从而实现排行榜功能。通过Sorted Set提供的操作，如添加成员、更新分数、根据分数范围获取成员等，可以方便地进行排行榜的维护和查询。 积分系统：可以使用Sorted Set来存储用户的积分，并按照积分进行排序。通过Sorted Set提供的操作，如添加成员、更新分数、根据分数范围获取成员等，可以方便地查询用户的排名、前几名用户等功能。 热门文章：可以使用Sorted Set来存储文章以及其阅读量或点赞数等指标，并按照指标进行排序。通过Sorted Set提供的操作，如添加成员、更新分数、根据分数范围获取成员等，可以方便地查询热门文章、热门标签等功能。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 向 Sorted Set 添加一个或多个原素，或者更新已存在元素的分数 ZADD key score1 value1 [score2 value2...] # 获取 Sorted Set 中元素的个数 ZCARD key # 移除 Sorted Set 中一个或多个原素 ZREM key value1 [value2...] # 获取 Sorted Set 中指定元素的分数 ZSCORE key value # 给指定元素添加分数 ZINCRBY key increment value # 根据分数范围获取 Sorted Set 中的元素 ZRANGEBYSCORE key score1 score2 # 通过索引返回 Sorted Set 中指定区间的成员（分数从低到高） ZRANGE key start stop # 通过索引返回 Sorted Set 中指定区间的成员（分数从高到低） ZREVRANGE key start stop # 获取指定元素排名，返回 Sorted Set 中的索引 ZRANK key value # 获取多个 Sorted Set 中的交集并存储在新的 Sorted Set 中 ZINTERSTORE destination numkeys key1 [key2...] # 获取多个 Sorted Set 中的并集并存储在新的 Sorted Set 中 ZUNIONSTORE destination numkeys key1 [key2...] # 获取多个 Sorted Set 中的差集并存储在新的 Sorted Set 中 ZDIFF destination numkeys key1 [key2...] Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Test void testZSet() { // 向 Sorted Set 添加一个或多个原素，或者更新已存在元素的分数 redisTemplate.opsForZSet().add(\u0026#34;myzset\u0026#34;, \u0026#34;value1\u0026#34;, 3.14); redisTemplate.opsForZSet().add(\u0026#34;myzset\u0026#34;, \u0026#34;value2\u0026#34;, 3.141); redisTemplate.opsForZSet().add(\u0026#34;myzset\u0026#34;, \u0026#34;value3\u0026#34;, 3.1415); // 获取 Sorted Set 中元素的个数 System.out.println(redisTemplate.opsForZSet().size(\u0026#34;myzset\u0026#34;)); // 移除 Sorted Set 中一个或多个原素 redisTemplate.opsForZSet().remove(\u0026#34;myzset\u0026#34;, \u0026#34;value3\u0026#34;); // 获取 Sorted Set 中指定元素的分数 System.out.println(redisTemplate.opsForZSet().score(\u0026#34;myzset\u0026#34;, \u0026#34;value1\u0026#34;)); // 给指定元素添加分数 redisTemplate.opsForZSet().incrementScore(\u0026#34;myzset\u0026#34;, \u0026#34;value2\u0026#34;, 1.1); // 根据分数范围获取 Sorted Set 中的元素 System.out.println(redisTemplate.opsForZSet().rangeByScore(\u0026#34;myzset\u0026#34;, 1, 6)); // 通过索引返回 Sorted Set 中指定区间的成员（分数从低到高） System.out.println(redisTemplate.opsForZSet().range(\u0026#34;myzset\u0026#34;, 1, 2)); // 通过索引返回 Sorted Set 中指定区间的成员（分数从高到低） System.out.println(redisTemplate.opsForZSet().reverseRange(\u0026#34;myzset\u0026#34;, 1, 2)); // 获取指定元素排名，返回 Sorted Set 中的索引 System.out.println(redisTemplate.opsForZSet().rank(\u0026#34;myzset\u0026#34;, \u0026#34;value1\u0026#34;)); // 获取多个 Sorted Set 中的交集并存储在新的 Sorted Set 中 redisTemplate.opsForZSet().add(\u0026#34;myzset1\u0026#34;, \u0026#34;value1\u0026#34;, 3.14); redisTemplate.opsForZSet().intersectAndStore(\u0026#34;newzset1\u0026#34;, \u0026#34;myzset1\u0026#34;, \u0026#34;myzset\u0026#34;); // 获取多个 Sorted Set 中的并集并存储在新的 Sorted Set 中 redisTemplate.opsForZSet().unionAndStore(\u0026#34;newzset1\u0026#34;, \u0026#34;myzset1\u0026#34;, \u0026#34;myzset\u0026#34;); // 获取多个 Sorted Set 中的差集并存储在新的 Sorted Set 中 redisTemplate.opsForZSet().differenceAndStore(\u0026#34;newzset1\u0026#34;, Collections.singleton(\u0026#34;myzset1\u0026#34;), \u0026#34;myzset\u0026#34;); } 高级数据结构 ","date":"2024-09-25T18:11:03+08:00","image":"https://limincai.github.io/p/redis-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/redis-quick-start-cover_hu10470396823172311135.jpg","permalink":"https://limincai.github.io/p/redis-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"Redis 快速入门"},{"content":"标题 # 内容为标题，几个#代表几级标题。\n一级标题 二级标题 三级标题 1 2 3 4 5 # 一级标题 ## 二级标题 ### 三级标题 引用块 \u0026gt; 内容为引用块，用于引用内容。\n引用块\n🪆 套娃引用块\n1 2 \u0026gt; 引用块 \u0026gt; \u0026gt;\u0026gt; 🪆 套娃引用块 代码块与代码段 代码块。\n1 代码段 1 2 3 4 5 6 7 `代码块`。 # 其中“java”为代码块语言，可以替换。 ```java System.out.println(\u0026#34;Hello, World!\u0026#34;); ``` 字体样式 斜体 *斜体* 斜体\n粗体 **粗体**\n粗体\n删除线 ~~删除线内容~~\n删除线内容\n下划线 \u0026lt;u\u0026gt;下划线内容\u0026lt;/u\u0026gt;\n下划线内容\n文本高亮 ==内容==\n==内容==\n文本上下标 我是文本^我是上标^\n我是文本我是下标\n1 2 3 我是文本^我是上标^ 我是文本~我是下标~ 分隔符 1 --- 表格 最上一排就是表头，需要在左右使用|表示这是一个表格，同时，下方需要添加分割线，分割线使用-减号表示。\n一 二 三 四 五 1 2 3 4 5 1 2 3 | 一 | 二 | 三 | 四 | 五 | | --- | --- | --- | --- | --- | | 1 | 2 | 3 | 4 | 5 | 其中：\n:--- 为左对齐 :---: 为剧中对齐 ---: 为右对齐 一 二 三 四 五 1 2 3 4 5 1 2 3 | 一 | 二 | 三 | 四 | 五 | | --: | --: | :-: | :-- | :-- | | 1 | 2 | 3 | 4 | 5 | 有序列表 输入当前序号后按退格键（Tab）可以变为子序号。\n一 二 三 四 1 2 3 4 1. 一 1. 二 1. 三 1. 四 无序列表 用法与有序列表类似。\n一 二 三 四 1 2 3 4 - 一 - 二 - 三 - 四 勾选框 我是未完成的任务 我是已完成的任务 1 2 - [ ] 我是未完成的任务 - [x] 我是已完成的任务 图片插入 html 写法 \u0026lt;img src=\u0026quot;图片路径\u0026quot; width=200 heigth=200\u0026gt;\nmarkdown 写法，这种写法无法主动修改图片尺寸。\n![图片描述](图片地址 \u0026quot;图片名称，可选\u0026quot;)\n链接 [链接文本](链接地址)\n有问题请百度\n脚注 java1是世界上最好的语言。\n1 2 java[^1]是世界上最好的语言。 [^1]:世界上最好的语言。 数学公式 公式块 需要编写数学公式，我们同样需要在特定的块中编写，公式块使用$美元符表示。多行公式使用连续的两个美元符： $$ 我是公式 $$ 1 2 3 $$ 我是公式 $$ 如果只想在行内编写，一行内容只需要使用一个美元符囊括即可：\n$ x = 17 + y $\n1 $ x = 17 + y $ 特殊数学符号 代码 符号 描述 \\not= \\= 不等于 \\approx ≈ 约等于 \\times × 乘号 \\div ÷ 除号 \\leq ≤ 小于等于 \\geq ≥ 大于等于 \\pm ± 正负号 \\sum ∑ 求和符号（累加） \\prod ∏ 累乘 \\coprod ∐ 累除 \\overline{a + b + c} a+b+c / 3 平均值 数学中常见特殊字符：\n代码 符号 代码 符号 \\alpha α \\beta β \\gamma γ \\delta δ \\epsilon ϵ \\eta η* \\theta θ \\pi π \\omega ω \\rho ρ \\sigma σ \\mu μ 常见的三角函数：\n代码 符号 描述 \\sin sin 正弦 \\cos cos⁡ 余弦 \\tan tan⁡ 正切 \\cot cot⁡ 余切 \\sec sec⁡ 正割 \\csc csc⁡ 余割 \\circ ∘ 度 积分和求导相关：\n代码 符号 描述 \\infty ∞ 无穷 \\int ∫ 定积分 \\iint ∬ 双重积分 \\iiint ∭ 三重积分 \\oint ∮ 曲线积分 x\\prime x′ 求导 \\lim lim⁡ 极限 集合相关：\n代码 符号 描述 \\emptyset ∅ 空集 \\in ∈ 属于 \\notin ∉ 不属于 \\supset ⊃ 真包含 \\supseteq ⊇ 包含 \\bigcap ⋂ 交集 \\bigcup ⋃ 并集 对数函数相关：\n代码 符号 描述 \\log log⁡ 对数函数 \\ln ln⁡ 以e为底的对数函数 \\lg lg⁡ 以10为底的对数函数 分数 $ \\frac{分子}{分母} $\n$ \\frac{分子}{分母} $\n开方 $\\sqrt{4}$\n$\\sqrt{4}$\n如果需要修改根号上方数值，可以添加中括号。\n$\\sqrt[3]{8}$\n$\\sqrt[3]{8}$\n上下标 ^ 表示上标，_表示下标。\n$ x_下标 $\n$ x^上标 $\n$ x^上标_下标 $\n1 2 3 $ x_下标 $ $ x^上标 $ $ x^上标_下标 $ 如果上标或下标内容多于一个字符，需要使用 {} 括起来，包括后续的其他代码如果出现只有一个字符生效的情况下，考虑使用花括号囊括全部内容：\n$ x*_{下标} $\n$ x^{上标} $\n$ x^{上标}_{下标} $\n1 2 3 $ x_{下标} $ $ x^{上标} $ $ x^{上标}_{下标} $ 积分 `$\\int_积分下限^积分上限xdx $\n$\\int_1^2xdx $\n极限 $ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n + 1} $\n$ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n + 1} $\n其他符号 代码 符号 描述 $ \\vec{a} $ $ \\vec{a} $ 向量符号 $ \\cdots $ $ \\cdots $ 居中省略号 $ \\ldots $ $ \\ldots $ 靠底部的省略号 $ \\cdot $ $ \\cdot $ 点乘号 $ \\sum*_1^n $* $ \\sum_1^n $* 累加 html 标签 markdown 支持 html 标签，可以更加个性化的自定义内容。\n例如：\n1 2 \u0026lt;iframe src=\u0026#34;https://limincai.github.io/\u0026#34; height=\u0026#34;1080\u0026#34; width=\u0026#34;1080\u0026#34; sandbox=\u0026#34;allow-scripts\u0026#34; scrolling=\u0026#34;yes\u0026#34;\u0026gt;\u0026lt;/iframe ","date":"2024-09-22T20:11:03+08:00","image":"https://limincai.github.io/p/markdown-%E8%AF%AD%E6%B3%95/markdown-synatax-cover_hu10298755978458750581.webp","permalink":"https://limincai.github.io/p/markdown-%E8%AF%AD%E6%B3%95/","title":"Markdown 语法"}]