[{"content":"前言 有一句话叫做：\n“学哲学一定要过康德之桥。”\n意思是康德是哲学路上的两个分水岭，这座桥分割了两个截然不同的世界。\n在桥的一头是被绝大多数人视为常识的且无条件接受的实在论，在这种世界观下，物质微粒依赖物理规律构成世间万物以及人类，并且这些物质都客观存在于一个被称为宇宙时空的巨大箱子里。\n在桥的另一头说德国古典观念论的起点，无数伟大的思想都从这里起步，康德、费希尔、黑格尔，最后在教科书上唯物史观的马克思都继承自观念论。\n康德作为一座桥，标志了人们在认识世界方式上的根本转向。\n在康德之前，哲学家们争论的焦点主要集中在“人的知识从何而来”这一问题上。其中分出了两个流派：唯理论和经验论。\n唯理论认为人的知识只能来源于理性，而且知识本身就包含在理性里，就想数学，只要拿出笔在纸上演算就能得出真理。\n经验论认为知识需要经过经验的检验，一切知识都在建立在经验的基础上，想要获取知识就必须走出家门，去观察，去做实验。\n《纯粹理性批判》就是为了解决这个争论，而整个《纯粹理性批判》实际上是康德再向人们展示人类心灵这个程序是如何通过编程和代码从一片空白的文档开始，一步一步加载出我们身处的大千世界。\n借着我写的一个贪吃蛇小游戏来解释人类心灵这个程序是怎么运行的。\n感性 在这段代码中，使用了`new ImageIcon`方法把图片资源加载到了程序当中，`new ImageIcon`就是康德所说的直观。 无论一种知识以什么方式以及通过什么手段与对象发生关系，它与对象直接发生关系所凭借的以及一切思维当作手段所追求的，就是直观。\n感官所给出的所有信号，味觉、嗅觉、听觉，我们将外部对象给出的刺激呈现在意识领域内的手段就是直观。康德将这一能力统称为感性。\n对应到游戏里，游戏源文件中的各种素材，都需要通过new ImageIcon这种方法才能添加到游戏的主程序中，当只有new ImageIcon，这些原始素材不但不能活动，甚至连呈现都做不到，因为此时的游戏还没有主界面。\n这里涉及到两块同样重要的代码，它们分别对应着康德的空间和时间，这里的空间和时间已经不同于日常生活中的、处在我们的、物理学意义上的时空。\n简而言之，康德认为，在我们去感受外部时空之前，我们的意识中必须先内置时空的表象，要呈现外部接受到的各种刺激，我们必须先内置一个能够提供各种刺激在其中排布变化的意识空间，也就是说我们必须先通过内置的代码展开一个游戏窗口。康德认为，没有一个任何一个直观到的表象可以脱离空间和时间。\n可以试着闭上眼睛想象一个圆形和方形，要么圆形和方形相互并列，要么圆形和方形相互嵌套或重叠，并且两个表象永远在你展开的意识空间里，没有这个预制的意识空间你根本无法做出任何相应的直观。你能想象什么都没有，却无法想象没有空间，当你开始想，你就意识到属于你的游戏窗口是永远敞开的状态。\n时间也相同，时间表象是我们连续绵延意识体验的基础，你听到或是想到的任何一个声响，体验到的任何一个变化，都以内时间表象为基础，我们体验到的每一个瞬间，都包含了上一时间的延续和下一时间的承接。如果我们不是先天地意识内就具有一种能象征并记录一切变化的能力，那外界的时间再如何流逝跟我们也没任何关系。\n时间和空间具有先验性，是一切直观的前提条件。时间与空间并不是我们通过经验学到的外部属性，而是先于经验内置于我们主体性的固有代码。\n经验论认为游戏是有原始素材构成，只要有足够的素材，就能拼出一款游戏。唯理论认为素材根本无所谓，只要埋头苦敲就能编出游戏。\n至此，程序中已经有了若干从外部提取的素材，一块呈现素材的窗口，以及让素材呈现发生变化的内部时钟。但距离能称得上是游戏，还差的很远。接下来就轮到知性发挥作用了。\n知性 感性只有直观的能力，感性只负责将对象产生的刺激带到意识中，而知性则负责对感性直观到的素材进行加工。这两种能力相辅相成。\n无感性就不会有对象被给予我们，无知性就不会有对象被思维。\n不妨看一眼窗外的景色，我们直观了这么庞杂的表象，无数的色块和线条相互堆叠，但眼前的一切看起来仍然井然有序，究其原因，是因为这些感性的素材并非孤立地呈现在我们意识中，而是经过了编码，封装成了一个个能被我们把握的对象。我们接受到的不是孤立的线条、色块、和声波的振动，而是一颗颗树木、一栋栋楼宇、一声声交谈，这种将感性疯长成具体对象的能力，也就是知性。\n回到贪球坤的游戏里，我们从程序外提取到的素材其实没有任何意义，它们无非是以特定的方式排列好的像素点而且，为了区分出身体以及食物，程序员需要创造出两个对象。当创造出身体，食物的对象后，下一步就是把这些对象融入到游戏的主程序中，进一步去规定这些对象之间的关系。比如头部与身体接触会如何，如果碰到墙壁又会如何。\n现实中也是一样，知性以类似的方式构建起人们对世界的认识。好比我们路过一个水果摊，知性便把感性直观到的各种颜色和形状封装成相应的水果对象，对象拥有类别、颜色、味道、形状等各种属性，同时还将水果这些对象跟我们联系在一起，比如喜恶关系、空间距离关系、所有权关系等。“苹果有益健康”、“苹果归水果摊所有”、“我要支付一定的金钱才能拥有这个苹果”，诸如此类的判断就是知性运行的结果。这些判断支撑起了每个人各自的那个大千世界。\n人的心灵并非是对外界的直接一比一的反应，我们眼中的苹果并非本来就是苹果本身，相反，一个人感受到的世界是由知性的判断搭建起来的，正如贪球坤游戏并不是真的吃到了球，而是底层经过编码各种对象间的相互关系。\n理性 理性-人类最高认识能力的终极体现。\n感性的对象是外界的各种刺激，知性则加工感性的素材得到判断，而理性所要探索的，是全知性共同遵守的普遍法则。放在游戏里，感性负责加载原始素材，知性是一行行敲出来的代码规定对象与对象间的关系，而理性，就是代码本身，或者说是每一行代码背后必须要遵守的那个基础规则。知性让我们产生认识，理性则要探索我们为什么能产生认识？这些认识产生的条件是什么？ 康德举了一个立法过程的例子来解释理性：如果把社会上实际发生的事件看做感性材料，比如说具体的一桩桩诈骗、抢劫、偷窃事件，那么我们通过立法对这些事件做出的规定就是知性，比如装订成册的宪法、刑法、民法，而理性，则是我们在立法时遵守的那个普遍原则，可以理解成公正、民主、和谐这类指导法律方向的普世价值。那么知性遵守什么法则呢，通过理性的工作，康德给出了他答案，那就是范畴。\n康德认为知性的一切活动都囊括在以上的4个大类，分别是量、制、关系以及模态之中。每个大类又区分出3个小类，一共12个范畴。每一个范畴代表了一种基本的判断形式。康德也解释不了为什么只能是这12个范畴。康德认为知性通过判断将我们认识的世界组织起来，而理性通过对判断分类得出范畴表。\n对应编程，范畴表可以理解为代码大全或是终极源代码一类的东西。\n当理性在面对一些特定的概念时会遇到怎么都无法解决的悖论，悖论的正方和反方在人的理性看来都同样有说服力，这样的悖论就是二律背反。\n正题 反题 宇宙在时间上有起点，在空间上也是有限的 宇宙在时间上没有起点，在空间中也没有任何限制 所有事物都无限可分，不存在一个不可分的基本粒子 所有事物都不可无限可分，存在一个不可分的基本粒子 在自然法则外，世上还存在自由意识 不存在自由意识，世上的一切都是必然 存在一个绝对者（上帝）是这个世界的成因 这个世界没有绝对者（上帝）作为成因 康德在《纯粹理性批判》中提出了以上四组二律背反。时空，物质，自由意识和上帝，在康德的时代代表了一种那时的形而上学对终极知识的追求。但理性却对这些问题毫无办法。\n康德认为四组二律背反分别是对四个对象做判断，但这四个对象都不能在我们的经验中出现，过去未来的时空，基本粒子，因果关系和上帝，从来只是一种推论，或者说它们是超验的，是超出经验范围内的，而我们的知性范畴只能处理经验中的对象，当运用与经验的范畴遇上了超验的对象自然就产生了二律背反的幻想。康德认为，二律背反产生的原因是超出正反题之外的。就像盲人摸象，一个人摸到象牙说大象是硬的，一个人摸到象耳说大象是软的，于是开始争论大象是硬的还是软的，但拥有视觉的人知道，大象是什么，根本是无关软硬度关系，是因为那两个盲人只有软硬这个范畴才产生相应的争论。\n在四个二律背反中，当我们讨论正题或反题时，人们就已经预设了时空、基本粒子、因果律和上帝是外在于我们心灵客观存在的对象，但在康德看来，我们永远无法知道什么是客观存在，我们永远无法知道世界本来的样子，就像一个程序员再精通编码，他也绝无可能将主板这些硬件呈现在屏幕上，我们能知道的，只有经过范畴编码的经验表象，而那个给我们以感性刺激的物自体则永远隐匿在经验之外。\n同样，因果关系也是我们连接经验表象的编码方式，物自体之间的关系也永远对我们隐匿，这就是康德对理性的批判。康德给理性花了一条界限并告诉我们，人只能认识界限以内的对象。可以把宇宙想象成一个装了最高级系统的主机，而每个人的心灵则是主机上运行的虚拟机，虚拟机从主机那只能接受与虚拟机系统兼容的数据，当我们在虚拟机内部试图用虚拟机的系统去探索主机上的对象时，不兼容的幻想就产生了。所以，不是我们的认识要符合对象，是对象要符合我们的认识形式，不是电脑能运行游戏本身，而是游戏本身要与电脑系统兼容。\n至此，认识论上的转向就完成了，康德之前的独断论者把宇宙看做客观存在的大箱子，物质则是箱子里摆放着的一件一件的物品，这些物品根据物理规律相互影响。而康德认为，时空是人的主观认识形式，对象的实存以及因果关系都是知性的判断，或者说客观存在和因果是我们对对象的一种编码，只是独断论者将这行代码赋予了比代码本身更优先的地位。\n如果一个最简单的小游戏都要经过几百行代码的编程，那么我们的心灵凭什么像镜子一样直白的反映出眼前的大千世界呢？\n","date":"2025-01-16T11:02:56+08:00","image":"https://limincai.github.io/p/%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4%E4%B8%8E%E7%A8%8B%E5%BA%8F/kangde-cover_hu11465904067428022108.png","permalink":"https://limincai.github.io/p/%E7%BA%AF%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4%E4%B8%8E%E7%A8%8B%E5%BA%8F/","title":"《纯粹理性批判》与程序"},{"content":"数据类型 数值型 名称 存储长度 描述 范围 smallint 2字节 小范围整数 -216 到 216 - 1 integer 4字节 常用的整数 -232 到 232 - 1 bigint 8字节 大范围整数 -264 到 264 - 1 decimal 可变长 用户指定的精度，准确 小数点前 131072 位；小数点后 16383 位 numeric 可变长 用户指定的精度，准确 小数点前 131072 位；小数点后 16383 位 real 4字节 可变精度，不准确 6 位十进制数字精度 double 8字节 可变精度，不准确 15 位十进制数字精度 字符串类型 名称 存储长度 描述 示例 char 1字节 固定长度字符 \u0026lsquo;A\u0026rsquo;,\u0026lsquo;z\u0026rsquo; varchar(n) 可变长 定长字符，最大长度n \u0026lsquo;hello\u0026rsquo; text 可变长 不限长度的字符串类型 \u0026lsquo;hello\u0026rsquo; 时间类型 名称 存储长度 描述 示例 data 4字节 日期 ‘2024-01-01\u0026rsquo; time 8字节 时间 \u0026lsquo;14:30:00 timestamp 8字节 日期时间 \u0026lsquo;2024-01-01 14:30:00\u0026rsquo; timestamptz 8字节 带时区的日期时间组合 \u0026lsquo;2024-01-01 14:30:00+08:00\u0026rsquo; interval 16字节 时间间隔，年/月/日等 \u0026lsquo;1 year 2 months 3 days\u0026rsquo; json 类型 名称 存储长度 描述 示例 json 可变长 JSON 数据存储 {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;John\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: 30} jsonb 可变长 二进制格式的 JSON {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;John\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: 30} 其他数据类型 名称 存储长度 描述 示例 bool 1字节 布尔值 true, false enum 可变长 用户自定义的枚举类型 \u0026lsquo;red\u0026rsquo;, \u0026lsquo;blue\u0026rsquo; bytea 可变长 存储二进制数据 \u0026lsquo;\\xDEADBEEF\u0026rsquo; array 可变长 数组存储类型 \u0026lsquo;{1, 2, 3}\u0026rsquo; uuid 16字节 uuid 550e8400-e29b-41d4 cidr 8字节 IPv4 或 IPv6 网络 \u0026lsquo;192.168.0.0/24\u0026rsquo; inet 8字节 IP 地址 \u0026lsquo;192.168.1.1\u0026rsquo; 实践使用 建表 sql：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 CREATE TABLE \u0026#34;users\u0026#34; ( user_id SERIAL PRIMARY KEY, -- 用户ID，自动递增 user_name VARCHAR(50) NOT NULL, -- 用户名 email VARCHAR(100) UNIQUE NOT NULL, -- 用户的邮箱，唯一且不能为空 password VARCHAR(255) NOT NULL, -- 用户的密码 date_of_birth DATE, -- 用户的出生日期 phone_number VARCHAR(20), -- 用户的电话号码 address TEXT, -- 用户的地址 created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 用户创建时间 updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- 用户更新时间 ); -- 创建触发器函数 CREATE OR REPLACE FUNCTION update_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = CURRENT_TIMESTAMP; -- 更新为当前时间 RETURN NEW; END; $$ LANGUAGE plpgsql; -- 创建触发器 CREATE TRIGGER set_updated_at BEFORE UPDATE ON \u0026#34;user\u0026#34; FOR EACH ROW EXECUTE FUNCTION update_updated_at(); UserMapper.xml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.mincai.study.postgresql.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.mincai.study.postgresql.domain.User\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;userId\u0026#34; column=\u0026#34;user_id\u0026#34; jdbcType=\u0026#34;INTEGER\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;userName\u0026#34; column=\u0026#34;user_name\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;password\u0026#34; column=\u0026#34;password\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;dateOfBirth\u0026#34; column=\u0026#34;date_of_birth\u0026#34; jdbcType=\u0026#34;DATE\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;phoneNumber\u0026#34; column=\u0026#34;phone_number\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;address\u0026#34; column=\u0026#34;address\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;createdAt\u0026#34; column=\u0026#34;created_at\u0026#34; jdbcType=\u0026#34;TIMESTAMP\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;updatedAt\u0026#34; column=\u0026#34;updated_at\u0026#34; jdbcType=\u0026#34;TIMESTAMP\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;sql id=\u0026#34;Base_Column_List\u0026#34;\u0026gt; user_id,user_name,email, password,date_of_birth,phone_number, address,created_at,updated_at \u0026lt;/sql\u0026gt; \u0026lt;/mapper\u0026gt; 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @SpringBootTest class PostgresqlApplicationTests { @Resource UserService userService; @Test void testUserService() { List\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { User user = new User(); user.setUserName(\u0026#34;用户\u0026#34; + i); user.setEmail(i + \u0026#34;@qq.com\u0026#34;); user.setPassword(UUID.randomUUID().toString()); user.setDateOfBirth(DateTime.now()); user.setPhoneNumber(String.valueOf(i)); user.setAddress(\u0026#34;111\u0026#34;); userList.add(user); } // 增 userService.saveBatch(userList); // 删除 userService.removeById(10); // 改 LambdaQueryWrapper\u0026lt;User\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.ge(User::getPhoneNumber, \u0026#34;3\u0026#34;); User user = new User(); user.setUserName(\u0026#34;new id\u0026#34;); userService.update(user, queryWrapper); userService.update(user, queryWrapper); // 查 List\u0026lt;User\u0026gt; users = userService.list(queryWrapper); System.out.println(users); } } ","date":"2024-12-24T16:29:18+08:00","image":"https://limincai.github.io/p/postgresql-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/postgresql-quick-start-cover_hu13566988909174606783.png","permalink":"https://limincai.github.io/p/postgresql-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"PostgreSql 快速入门"},{"content":"编程是一个抽象到具体的不断进化 目前我对编程的理解大概有四个层次。\n第一层，学习语言与技术。这是编程的起点，是一个高度抽象的过程，侧重于掌握工具和技术的基础。（学技术） 第二层是实际操作项目。这一层面转向具体应用，编程的目标是解决现实中的问题。（用轮子） 第三层又回到了抽象，回到抽象。这一层次是对前面问题的共性进行总结，开发通用的解决方案，相当于“造轮子”的过程。（造轮子） 第四层为终极一层，终极目标。这是我作为编程爱好者的追求，整合上述三个层次的成果，追求完美的解决方案，涵盖了抽象的理念和集体的协作。Make it work, make it right, make it fast。 每一层次都为下一层提供基础，它们彼此相辅相成。\n代码的实现（具体）始终建立在对抽象的理解和设计上，而抽象与具体又是相互依存、相互促进的。\n编程的哲学 从混沌到秩序：编程始于模糊的需求，经过抽象的思考，逐步澄清问题，最终通过具体的实现将理论转化为现实，创造出有实际操作性的成果。\n重复无休止，问题的永恒性：编程是一个不断在抽象与具体化之间往返的过程，类似于哲学中对真理的追寻。这种追寻并不是无意义，是对于未知的探索，有着反思性。\n存在论：“创造意义”：不仅仅是为了写代码，而是对代码注入思想的价值，赋予代码一种“存在”的意义。\n","date":"2024-11-28T11:09:50+08:00","image":"https://limincai.github.io/p/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B/about-program-cover_hu4724448080955004898.jpg","permalink":"https://limincai.github.io/p/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B/","title":"关于编程"},{"content":"延迟消息：生产者发送消息是指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。\n延迟消息：设置在一定时间之后才执行的任务。\n死信交换机 当一个队列满足下列情况之一时，就会变成死信（dead letter）：\n消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的 requeue 参数为 false。 消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费。 要投递的队列消息堆积满了，最早的消息可能成为死信。 如果队列通过 dead-letter-exchaneg 属性指定了一个队列，那么该队列中的死信就会投递到这个交换机中。这个交换机成为死信交换机（Dead Letter Exchange）。\npublisher 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @SpringBootTest @Slf4j class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testDlxQueue() { // 交换机 String exchangeName = \u0026#34;simple.direct\u0026#34;; // routing key String routingKey = \u0026#34;hi\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, routingKey, \u0026#34;死信队列消息\u0026#34;, message -\u0026gt; { // 设置过期时间，单位为 ms message.getMessageProperties().setExpiration(\u0026#34;1000\u0026#34;); return message; }); } } consumer 端代码：\n1 2 3 4 5 6 7 8 9 10 @Component @Slf4j public class TestListener { @RabbitListener(queues = \u0026#34;dlx.queue\u0026#34;) public void listenDlxQueue(String message) { log.info(\u0026#34;处理死信队列的消息\u0026#34;); log.info(\u0026#34;dlx.queue 的消息：{}\u0026#34;, message); } } 消费者不需要监听 simple.queue 的队列，simple.queue 的消息会自动被监听 dlx.queue 的消费者给消费掉。\n这种方式实现延迟队列，只有位于顶端的消息先被消费后才能消费下一个消息。比较不推荐。\n延迟消息插件 RabbitMQ 推出了一个插件，原生支持延迟消息功能。\n延迟消息插件安装：github地址。\n（1）先找到 RabbitMQ 安装插件位置：\n1 rabbitmq-plugins directories -s （2）把下载好的插件解压到文件夹内后启动插件：\n1 rabbitmq-plugins enable rabbitmq_delayed_message_exchange 消费者在声明交换机时，需要把 exchange 的 delayed 属性改为 true。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component @Slf4j public class TestListener { @RabbitListener( bindings = @QueueBinding( value = @Queue(name = \u0026#34;dlx.queue\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(name = \u0026#34;dlx.direct\u0026#34;, delayed = \u0026#34;true\u0026#34;), key = \u0026#34;hi\u0026#34; ) ) public void listenDlxQueue(String message) { log.info(\u0026#34;处理死信队列的消息\u0026#34;); log.info(\u0026#34;dlx.queue 的消息：{}\u0026#34;, message); } } 生产者在设置消息的过期时间方式也有所改变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @SpringBootTest @Slf4j class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testDlxQueue() { // 交换机 String exchangeName = \u0026#34;simple.direct\u0026#34;; // routing key String routingKey = \u0026#34;hi\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, routingKey, \u0026#34;死信队列消息\u0026#34;, message -\u0026gt; { // 设置过期时间，单位为 ms message.getMessageProperties().setDelay(1000); return message; }); } } 这种方式设计的延迟队列，消息会根据过期时间从队列中取出。\n延迟消息解决思路 延迟消息因为有过期时间的特性，当过期时间过长时，会导致队列堆积大量消息，浪费资源。\n例如支付业务，30分钟未支付就会取消订单，大部分用户会在30分钟内支付订单，可以将30分钟分成数个时间段，每隔一段时间发送一次延迟消息，检查一下订单状态，减少没必要的等待，如果未支付继续发送一定时间的延迟消息，直到30分钟为止。\n","date":"2024-11-06T12:58:46+08:00","image":"https://limincai.github.io/p/rabbitmq-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/redis-delayqueue-cover_hu14173519126278742727.png","permalink":"https://limincai.github.io/p/rabbitmq-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/","title":"RabbitMQ 延迟队列"},{"content":"生产者可靠性 生产者重连 由于网络波动，可能出现客户端连接 MQ 失败的情况。可以通过配置生产者的 application.yaml 来开启失败后的重连机制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 spring: rabbitmq: # 设置 MQ 的连接超时时间 connection-timeout: 1s template: retry: # 开启失败重试机制 enabled: true # 失败后的初始等待时间 initial-interval: 1000ms # 失败后的下次等待时间，下次等待时间 = initial-interval * multiplier multiplier: 1 # 最大重试次数 max-attempts: 3 生产者确认 RabbitMQ 有 Publisher Confirm 和 Publisher Return 两种确认机制。开启确认机制后，在 MQ 成果收到消息后会返回确认信息给生产者。返回到结果一以下几种情况：\n消息投递到了 MQ，但是路由失败（routing key 没有匹配，一般为自己业务问题）。此时会通过 Publisher Return 返回路由异常原因，然后返回 ACK，告知投递成功。 临时消息（非持久的消息）投递到了 MQ，并且入列成功，返回 ACK， 告知投递成功。 持久化消息投递到了MQ，并且入列完成持久化，返回 ACK，告知投递成功。 其他情况都会返回 NACK，告知投递失败。 在 publisher 的 application.yaml 中添加配置。 1 2 3 4 5 6 spring: rabbitmq: # 开启 publisher confirm 机制，并设置 confirm 类型 publisher-confirm-type: correlated # 开启 publisher return 机制 publisher-returns: true Publisher-confirm-type 有三种模式：\nnone：关闭 confirm 机制。 simple：同步阻塞等待 MQ 的回执消息。 correlated：MQ 异步回调方式返回回执消息。 每个 RabbitTemplate 只能配置一个 ReturnCallback，因此需要在项目启动过程中配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Configuration @Slf4j public class CommonConfig implements ApplicationContextAware { @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { // 获取 RabbitTemplate RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class); // 设置 ReturnCallback rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnsCallback() { @Override public void returnedMessage(ReturnedMessage returnedMessage) { log.info( \u0026#34;收到消息的 Return Callback，message:{}，\u0026#34; + \u0026#34;replyCode:{}，replyText:{}，\u0026#34; + \u0026#34;exchange:{}，routingKey:{}\u0026#34;, returnedMessage.getMessage(), returnedMessage.getReplyCode(), returnedMessage.getReplyText(), returnedMessage.getExchange(), returnedMessage.getRoutingKey()); } }); } } 发送消息，指定消息 ID、消息 ConfirmCallback。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @SpringBootTest @Slf4j class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testPublisherConfirm() { // 1.创建 CorrelationData，并指定 id CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString()); // 2.给 Future 添加 ConfirmCallback correlationData.getFuture().addCallback(new ListenableFutureCallback\u0026lt;CorrelationData.Confirm\u0026gt;() { @Override public void onFailure(Throwable ex) { // Future 发生异常时的处理逻辑 log.error(\u0026#34;handle message ack fail\u0026#34;, ex); } @Override public void onSuccess(CorrelationData.Confirm result) { // Future 接收到回执的处理逻辑，参数中的 result 就是回执类型 log.info(\u0026#34;收到 confirm callback 回执\u0026#34;); if (result.isAck()) { log.debug(\u0026#34;发送消息成功，收到 ACK！\u0026#34;); } else { log.error(\u0026#34;发送消息失败，收到 NACK，原因：{}\u0026#34;, result.getReason()); } } }); // 3.发送消息 rabbitTemplate.convertAndSend(\u0026#34;direct.exchange\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;hello\u0026#34;, correlationData); } } MQ 的可靠性 在默认情况下，RabbitMQ 会将接收到的消息保存在内存中以降低消息收发的延迟。这样会导致两个问题：\n一旦 MQ 宕机，内存中的消息会丢失。 内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发 MQ 阻塞。 数据持久化 RabbitMQ 实现数据持久化包括3个方面：\n交换机持久化 队列持久化 消息持久化 其中“交换机持久化”和“队列持久化” Spring 默认处理就是持久化。\n“消息持久化”可以通过设置消息的属性来进行持久化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @SpringBootTest @Slf4j class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testDurability() { Message message = MessageBuilder. withBody(\u0026#34;hello\u0026#34;.getBytes(StandardCharsets.UTF_8)). setDeliveryMode(MessageDeliveryMode.PERSISTENT). build(); rabbitTemplate.convertAndSend(\u0026#34;simple.queue\u0026#34;, message); } } LazyQueue 惰性队列的特征如下：\n接收到消息后直接存入磁盘而非内存，内存中只保留最近的消息，默认2048条。 消费者要消费消息才会从磁盘中读取而非加载到内存。 支持数百万的消息存储。 目前 RabbitMQ 的所有队列都是 Lazy Queue 模式，无法更改。\n消费者可靠性 消费者确认 为了确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制（Cosumer Acknowledegement）。当消费者处理消息结束后，应该向 RabbitMQ 发送一个回执，告知 RabbitMQ 自己消息处理状态。回执有三种状态：\nack：成功处理消息，RabbitMQ 从队列中删除消息。 nack：消息处理失败，RabbitMQ 需要再次投递消息。 reject：消息处理失败并拒绝消息，RabbitMQ 从队列中删除消息。 其中 SpringAMQP 已经实现了消息确认功能，并且可以通过修改配置文件选择 ACK 处理方式，有三种方式：\nnone：不处理。即消息投递给消费者后立刻 ack，消息会立刻从 MQ 中删除，非常不安全。\nmanual：手动模式。需要自己在业务中调用 api，发送 ack 或 reject，存在业务入侵，但更灵活。\nauto：自动模式。Spring AMQP 利用 AOP 对消息处理逻辑做了环绕增强：\n当业务正常执行时返回 ack。\n当业务出现异常，如果是业务异常，返回 nack。\n如果是消息处理或校验异常，返回 reject。\napplication.yaml：\n1 2 3 4 5 spring: rabbitmq: listener: simple: acknowledge-mode: auto publisher 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @SpringBootTest @Slf4j class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testConsumerAcknowledgement() { // 交换机名称 String exchangeName = \u0026#34;fanout.exchange\u0026#34;; // 消息 String message = \u0026#34;hello,fanout exchange\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, \u0026#34;consumerack\u0026#34;, message); } } consumer 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component @Slf4j public class TestListener { @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \u0026#34;fanout.queue\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(value = \u0026#34;fanout.exchange\u0026#34;, type = ExchangeTypes.FANOUT), key = \u0026#34;consumerack\u0026#34;)) public void testConsumerAcknowledgement(Message message, Channel channel) throws IOException { try { // 处理消息 System.out.println(\u0026#34;收到消息: \u0026#34; + new String(message.getBody())); // 如果消息成功处理，手动确认 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); } catch (Exception e) { // 如果处理失败，拒绝消息，RabbitMQ 会重新投递 channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true); } } } 失败重试机制 当消费者出现异常后，消息会不断 requeue 到队列，再重新发给消费者，然后再次异常，再次 requeue，导致 MQ 的消息处理飙升，带来不必要的压力。\n可以利用 Spring 的 retry 机制，在消费者出现异常时利用本地重试，而不是无限制的 requeue 到 MQ 队列。\napplcation.yaml\n1 2 3 4 5 6 7 8 9 10 spring: rabbitmq: listener: simple: retry: enabled: true # 开启消费者失败重试 initial-interval: 1000ms # 初始的失败重试等待时长 multiplier: 1 # 下次失败重试的等待时长 = initial-interval * multiplier max-attempts: 3 # 最大重试次数 stateless: true # true 无状态；false 有状态。如果业务中包含事务，这里改为 true 在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有 MessageRecocver 接口来处理，它包含三种不同的实现：\nRejectAndDontRequeueRecoverer：重试耗尽后，直接 reject，丢弃消息。默认就是这种方法。 ImmediateRequeueMessageRecoverer：重试耗尽后，返回 nack，消息重新入队。 RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机。 这里采用 RepublishMessageRecoverer 的方案。\n（1）定义接收失败消息的交换机、队列以及绑定关系。\n（2）定义 RepublishMessageRecoverer：\n1 2 3 4 5 6 7 public class RabbitMQConfig { @Bean public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate) { return new RepublishMessageRecoverer(rabbitTemplate, \u0026#34;error.direct\u0026#34;, \u0026#34;error\u0026#34;); } } 业务幂等性 业务 幂等性指同一个业务，执行一次和执行多次对业务状态对影响是一致的。\n为了防止消息被多次消费，需要采取措施来实现业务幂等性。\n方案一：唯一消息 id 给每一个消息设置一个唯一 id，利用 id 区分是否重复消费：\n每一条消息都生成一个唯一的 id，与消息一起投递给消费者。 消费者接收到消息后处理自己的业务，业务处理成功后将消息 id 保存到数据库。 如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。 1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class RabbitMQMessageConfig { @Bean public MessageConverter messageConverter() { // 定义消息转换器 Jackson2JsonMessageConverter jjmc = new Jackson2JsonMessageConverter(); // 配置自动创建 id，用于识别不同消息，也可以在业务中基于 id 判断是否是重复消息 jjmc.setCreateMessageIds(true); return jjmc; } } 方案二：业务判断 结合业务逻辑，基于业务本身做判断。举例：在支付订单后修改订单状态为以支付，应该在修改订单状态前先查询订单状态，判断状态是否是未支付。只有未支付订单才需要修改，其他状态不做处理：\n","date":"2024-11-02T16:54:50+08:00","image":"https://limincai.github.io/p/rabbitmq-%E5%8F%AF%E9%9D%A0%E6%80%A7/rabbitmq-reliability-cover_hu14182550218619205663.png","permalink":"https://limincai.github.io/p/rabbitmq-%E5%8F%AF%E9%9D%A0%E6%80%A7/","title":"RabbitMQ 可靠性"},{"content":"RabbitMQ 核心概念及整体架构 virtual-host：虚拟主机，起到数据隔离的作用。 publisher：消息发送者。 sconsumer：消息的消费者。 queue：队列，存储消息。 exchange：交换机，负责路由消息。 Springboot 项目使用 RabbitMQ 依赖引入 pom.xml：\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置 application.yaml：\n1 2 3 4 5 6 7 spring: rabbitmq: host: localhost\tport: 5672\tusername: guest\tpassword: guest\tvirtual-host: /\tconfiguration 类配置序列化：\n1 2 3 4 5 6 7 8 9 @Configuration public class RabbitMQMessageConfig { @Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } } 测试 publisher 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @SpringBootTest class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testConnection() { // 队列名称 String queueName = \u0026#34;test.queue\u0026#34;; // 消息 String message = \u0026#34;test\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(queueName, message); } } consumer 端代码：\n1 2 3 4 5 6 7 8 9 10 @Component @Slf4j public class TestListener { @RabbitListener(queues = \u0026#34;test.queue\u0026#34;) public void listenTestQueue(String message) { System.out.println(message); } } 声明队列和交换机的方式 配置类 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.mincai.study.consumer.config; import org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @author limincai */ @Configuration public class FanoutConfig { /** * 声明 Fanout 交换机 */ @Bean public FanoutExchange fanoutExchange1() { // return ExchangeBuilder.fanoutExchange(\u0026#34;exchange.fanout\u0026#34;).build(); return new FanoutExchange(\u0026#34;exchange.fanout\u0026#34;); } /** * 声明一个队列 */ @Bean public Queue fanoutQueue1() { // return QueueBuilder.durable(\u0026#34;fanout.queue1\u0026#34;).build(); // 用下面这种方式，默认持久化 return new Queue(\u0026#34;fanout.queue1\u0026#34;); } /** * 绑定队列1和交换机1 */ @Bean public Binding fanoutBuilding1(Queue fanoutQueue1, FanoutExchange fanoutExchange1) { return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange1); } } 注解 在监听的方法上使用 @RabbitListener 注解\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Component public class TestListener { @RabbitListener( bindings = @QueueBinding( // 绑定的队列 value = @Queue(value = \u0026#34;fanout.queue1\u0026#34;, durable = \u0026#34;true\u0026#34;), // 绑定的交换机 exchange = @Exchange(value = \u0026#34;fanout.exchange1\u0026#34;, type = ExchangeTypes.FANOUT), // Binging Key key = \u0026#34;fanoutkey\u0026#34;)) public void listenFanoutQueue1(String message) { System.err.println(\u0026#34;消费者1收到了 fanout queue1 的消息：\u0026#34; + message); } } Work Queues 让多个消费者绑定到一个队列，共同消费队列中的消息。\n测试 publisher 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @SpringBootTest class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testWorkQueue() throws InterruptedException { // 队列名称 String queueName = \u0026#34;work.queue\u0026#34;; for (int i = 0; i \u0026lt; 50; i++) { // 消息 String message = \u0026#34;hello,message_\u0026#34; + i; // 发送消息 rabbitTemplate.convertAndSend(queueName, message); Thread.sleep(20); } } } consumer 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component @Slf4j public class TestListener { @RabbitListener(queues = \u0026#34;work.queue\u0026#34;) public void listenWorkQueue1(String message) { System.out.println(\u0026#34;消费者1收到了 work queue 的消息：\u0026#34; + message); } @RabbitListener(queues = \u0026#34;work.queue\u0026#34;) public void listenWorkQueue2(String message) { System.err.println(\u0026#34;消费者2收到了 work queue 的消息：\u0026#34; + message); } } 消费者1和消费者2轮询消费了 work.queue 中的消息。\n默认情况下，RabbitMQ 会将消息轮询投递给绑定在队列上的每一个消费者。可以修改 consumer 的配置，将 prefetch 设置为1，确保同一时刻最多投递给消费者1条消息：\n1 2 3 4 5 6 spring: rabbitmq: listener: simple: # 每次只能获取一条消息，处理完成才能获取下一条消息 prefetch: 1 Fanout 交换机 Fanout Exchange 会将接收到的消息广播到每一个跟其绑定的 queue。\n测试 publisher 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @SpringBootTest class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testFanoutExchange() { // 交换机名称 String exchangeName = \u0026#34;fanout.exchange\u0026#34;; // 消息 String message = \u0026#34;hello,fanout exchange\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, \u0026#34;\u0026#34;, message); } } consumer 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component @Slf4j public class TestListener { @RabbitListener(queues = \u0026#34;fanout.queue1\u0026#34;) public void listenFanoutQueue1(String message) { System.out.println(\u0026#34;消费者1收到了 fanout queue1 的消息：\u0026#34; + message); } @RabbitListener(queues = \u0026#34;fanout.queue2\u0026#34;) public void listenFanoutQueue2(String message) { System.out.println(\u0026#34;消费者2收到了 fanout queue2 的消息：\u0026#34; + message); } } Direct 交换机 Direct Exchange 会将收到的消息根据规则路由到指定的 queue。\n每一个 queue 都与 Exchange 绑定一个 Binging Key。 发布者发送消息时，指定消息的 Routing Key。 Exchange 将消息路由到 Binging Key 与消息 Routing Key 一致的队列。 测试 publisher 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testDirectExchange() { // 交换机名称 String exchangeName = \u0026#34;direct.exchange\u0026#34;; // routing key String routingKey = \u0026#34;blue\u0026#34;; // 消息 String message = \u0026#34;hello,direct exchange\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, routingKey, message); } } consumer 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Component @Slf4j public class TestListener { @RabbitListener( bindings = @QueueBinding( value = @Queue( value = \u0026#34;direct.queue1\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(value = \u0026#34;direct.exchange\u0026#34;, type = \u0026#34;direct\u0026#34;), key = {\u0026#34;red\u0026#34;})) public void listenDirectQueue1(String message) { System.out.println(\u0026#34;消费者1收到了 direct queue1 的消息：\u0026#34; + message); } @RabbitListener( bindings = @QueueBinding( value = @Queue( value = \u0026#34;direct.queue2\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(value = \u0026#34;direct.exchange\u0026#34;, type = \u0026#34;direct\u0026#34;), key = {\u0026#34;yellow\u0026#34;})) public void listenDirectQueue2(String message) { System.err.println(\u0026#34;消费者2收到了 direct queue2 的消息：\u0026#34; + message); } } Topic 交换机 Topic Exchange 与 Direct Exchange 类似，区别在于 Binging Key 可以有更多规则。\n#：代指0个单词。 *：代指1个单词。 测试 publisher 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest class PublisherApplicationTests { @Resource private RabbitTemplate rabbitTemplate; @Test void testTopicExchange() { // 交换机名称 String exchangeName = \u0026#34;topic.exchange\u0026#34;; // routing key String routingKey = \u0026#34;china.news\u0026#34;; // 消息 String message = \u0026#34;hello,topic exchange\u0026#34;; // 发送消息 rabbitTemplate.convertAndSend(exchangeName, routingKey, message); } } consumer 端代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component @Slf4j public class TestListener { @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \u0026#34;topic.queue1\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(value = \u0026#34;direct.exchange\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;#.news\u0026#34;)) public void listenTopicQueue1(String message) { System.out.println(\u0026#34;消费者1收到了 topic queue1 的消息：\u0026#34; + message); } @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \u0026#34;topic.queue2\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(value = \u0026#34;direct.exchange\u0026#34;, type = ExchangeTypes.TOPIC), key = \u0026#34;china.#\u0026#34;)) public void listenTopicQueue2(String message) { System.err.println(\u0026#34;消费者2收到了 topic queue2 的消息：\u0026#34; + message); } } ","date":"2024-10-30T15:15:00+08:00","image":"https://limincai.github.io/p/rabbitmq-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/rabbitmq-quick-start-cover_hu12896635817044485726.png","permalink":"https://limincai.github.io/p/rabbitmq-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"RabbitMQ 快速入门"},{"content":"先更新缓存，再更新数据库 由于网络问题，请求顺序无法保证，可能出现先更新缓存的请求，后更新数据库，而后更新缓存的请求反而更新了数据库，这样就出现了缓存数据为20，数据库数据为10，数据不一致。\n先更新数据库，再更新缓存 先删除缓存，再更新数据库 ","date":"2024-10-20T21:12:22+08:00","image":"https://limincai.github.io/p/redis-%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/redis-consistency-cover_hu17064654486782066597.png","permalink":"https://limincai.github.io/p/redis-%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/","title":"Redis 解决数据一致性问题"},{"content":"缓存穿透 缓存穿透：指查询一个不存在的数据，缓存中没有相应的记录，每次请求都会去访问数据库，使数据库负担加大。\n解决方案 缓存空数据，对查询结果进行缓存，即使是不存在的数据，也可以缓存一个标识，以减少对数据库的请求。 使用布隆过滤器，过滤到不存在的请求，避免直接访问数据库。 解决方案对比 解决方案 优点 缺点 缓存空对象 实现简单，方便维护 额外的内存消耗可能造成短期的不一致 布隆过滤器 内存占用较小，没有多余 key 实现复杂存在误判可能 缓存空对象 Java 实现 流程图：\nJava 业务代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * @author limincai */ @Service public class GoodServiceImpl extends ServiceImpl\u0026lt;GoodMapper, Good\u0026gt; implements GoodService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Good getGood(Integer goodId) { String key = \u0026#34;good:\u0026#34; + goodId; // 1.从 redis 中查询商品缓存 String goodJson = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(goodJson)) { // 存在直接返回 return JSONUtil.toBean(goodJson, Good.class); } // 3.判断命中的是否是空值 if (goodJson != null) { // 是则直接返回空值 return null; } // 4.不存在，查询数据库 Good good = getById(goodId); // 5.数据库中不存在，则将空值写入 redis 并设置过期时间 if (good == null) { stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;, 30, TimeUnit.SECONDS); return null; } // 6.数据库中存在，则重建缓存 stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(good), 30, TimeUnit.SECONDS); return good; } } 缓存击穿 缓存击穿：指某个热点数据在缓存中失效，导致大量请求直接访问数据库。此时，由于瞬间的高并发，可能导致数据库崩溃。\n解决方案 使用互斥锁，确保同一时间只有一个请求可以去数据库查询并更新缓存。当缓存未命中时，当前线程获得锁并去查询数据库重新缓存数据。缺点是性能较差，当前线程拿到互斥锁时，其他线程只能等待。 逻辑过期，热点数据永不过期。若当前线程发现数据逻辑时间已过期，就去获得互斥锁，并开启一个新的线程去查询数据库重新建立缓存，并返回已过期的数据。当其他线程获取互斥锁失败时，直接返回过期数据。当缓存重新建立时，此时释放锁，其他线程可以直接命中缓存。 解决方案对比 解决方案 优点 缺点 互斥锁 没有额外内存消耗保证一致性实现简单 没有额外内存消耗可能有死锁风险 逻辑过期 线程无需等待 不保证一致性有额外内存消耗实现复杂 互斥锁 Java 实现 流程图：\nJava 业务代码：\n其中 tryLock() 和 unLock() 可以使用 ReentrantLock 对象的 tryLock() 和 unLock() 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 /** * @author limincai */ @Service public class GoodServiceImpl extends ServiceImpl\u0026lt;GoodMapper, Good\u0026gt; implements GoodService { private Lock lock = new ReentrantLock(); @Resource private StringRedisTemplate stringRedisTemplate; @Override public Good getGood(Integer goodId) { String key = \u0026#34;good:\u0026#34; + goodId; // 1.从 redis 中查询商品缓存 String goodJson = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(goodJson)) { // 如果存在直接返回 return JSONUtil.toBean(goodJson, Good.class); } // 3.不存在实现缓存重建 // 3.1.获取互斥锁 Good good; String lockKey = \u0026#34;lock:good:\u0026#34; + goodId; try { if (tryLock(lockKey)) { // 3.2.获取成功，查询数据库更新缓存 good = getById(goodId); // 模拟重建的延时 Thread.sleep(200); if (good == null) { // 3.2.1. 数据库中不存在，在 redis 中存入空值并返回空 stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;, 30, TimeUnit.SECONDS); return null; } else { // 3.2.2. 数据库中存在数据更新缓存 stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(good)); } } else { // 3.3.获取失败，休眠一段时间重新 Thread.sleep(50); return getGood(goodId); } } catch (InterruptedException e) { throw new RuntimeException(e); } finally { // 4.释放互斥锁 unLock(lockKey); } return good; } /** * 获取锁 * * @param key redis key * @return 是否获取成功 */ private boolean tryLock(String key) { // 当成功设置值时，说明可以获得锁，返回 true，否则返回 false // 给锁设置一个有效期，防止出现死锁 Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \u0026#34;1\u0026#34;, 50, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } /** * 释放锁 * * @param key redis key */ private void unLock(String key) { stringRedisTemplate.delete(key); } } 逻辑过期 Java 实现 流程图：\n首先先新建一个对象，里面有一个属性作为过期时间，另外一个属性为数据对象，这样不需要修改原来代码就能让数据对象拥有逻辑过期时间属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @author limincai */ @Data @Getter @Setter public class RedisData { /** * 逻辑过期时间 */ private LocalDateTime expireTime; /** * 数据对象 */ private Object data; } Java 业务代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 /** * @author limincai */ @Service public class GoodServiceImpl extends ServiceImpl\u0026lt;GoodMapper, Good\u0026gt; implements GoodService { /** * 缓存重建线程池 */ private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); @Resource private StringRedisTemplate stringRedisTemplate; @Override public Good getGood(Integer goodId) { String key = \u0026#34;good:\u0026#34; + goodId; // 1.从 redis 中查询商品缓存 String goodJson = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(goodJson)) { // 如果不存在直接返回空 return null; } // 3.存在 RedisData redisData = JSONUtil.toBean(goodJson, RedisData.class); Good good = JSONUtil.toBean((JSONObject) redisData.getData(), Good.class); // 4.判断缓存是否过期 if (redisData.getExpireTime().isAfter(LocalDateTime.now())) { // 未过期则直接返回过期数据 return good; } // 5.过期则虚缓存重构 // 5.1.获取互斥锁 String lockKey = \u0026#34;lock:good:\u0026#34; + goodId; try { if (tryLock(lockKey)) { // 5.2.获取成功，新建一个缓存查询数据库更新缓存 CACHE_REBUILD_EXECUTOR.submit(() -\u0026gt; { saveGoodToRedis(goodId, 30L); }); good = getById(goodId); } } catch (Exception e) { throw new RuntimeException(e); } finally { // 5.4.释放互斥锁 unLock(lockKey); } // 5.5.缓存失败直接返回过期数据 return good; } /** * 把封装逻辑过期时间的数据对象到 redis * * @param goodId 商品 id * @param expireSeconds 过期时间（秒） */ public void saveGoodToRedis(Integer goodId, Long expireSeconds) { // 1.查询店铺数据 Good good = getById(goodId); // 2.封装逻辑过期时间 RedisData redisData = new RedisData(); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); redisData.setData(good); // 3.写入到 redis stringRedisTemplate.opsForValue().set(\u0026#34;good:\u0026#34; + goodId, JSONUtil.toJsonStr(redisData)); } /** * 获取锁 * * @param key redis key * @return 是否获取成功 */ private boolean tryLock(String key) { // 当成功设置值时，说明可以获得锁，返回 true，否则返回 false // 给锁设置一个有效期，防止出现死锁 Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \u0026#34;1\u0026#34;, 50, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } /** * 释放锁 * * @param key redis key */ private void unLock(String key) { stringRedisTemplate.delete(key); } } 缓存雪崩 缓存雪崩：指多个缓存数据中同一时间过期或者 Redis 服务宕机，导致大量的请求访问数据库，从而造成数据库瞬间负载激增。\n解决方案 采用随机过期时间策略，避免多个数据同时过期。 使用双缓存策略，将数据同时存储在两层缓存中，减少数据库的直接请求。 利用 Redis 集群提高服务的可用性。 给缓存业务添加降级限流策略。 随机过期时间 Java 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * @author limincai */ @Service public class GoodServiceImpl extends ServiceImpl\u0026lt;GoodMapper, Good\u0026gt; implements GoodService { @Resource private StringRedisTemplate stringRedisTemplate; @Override public Good getGood(Integer goodId) { String key = \u0026#34;good:\u0026#34; + goodId; // 1.从 redis 中查询商品缓存 String goodJson = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(goodJson)) { // 存在直接返回 return JSONUtil.toBean(goodJson, Good.class); } // 3.不存在查询数据库 Good good = getById(goodId); // 4.数据库中不存在，返回空 if (good == null) { return null; } // 5.数据库中存在，重建缓存,并给过期时间额外添加随机值防止同时过期 // 生成 5 - 10 的随机数，作为随机的过期时间 Random rand = new Random(); int randomTTL = rand.nextInt((10 - 5) + 1) + 5; stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(good), 30 + randomTTL, TimeUnit.SECONDS); return good; } } ","date":"2024-10-13T21:47:45+08:00","image":"https://limincai.github.io/p/redis-%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/redis-hcjc-cover_hu13619607647227089532.png","permalink":"https://limincai.github.io/p/redis-%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/","title":"Redis 解决缓存穿透、缓存击穿和缓存雪崩"},{"content":"文档参考：Redis 官方文档\nSpringBoot 项目使用 Redis 依赖引入 在 Springboot 项目中，添加如下依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- Redis 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Json 序列化依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jsr310\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.13.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置 Redis 新建一个 RedisConfig 类用于 Redis 的配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Redis 配置类 * * @author limincai */ @Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory connection) { RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate = new RedisTemplate\u0026lt;\u0026gt;(); redisTemplate.setConnectionFactory(connection); // 设置键序列化器为 StringRedisSerializer，所有的键会被序列化为字符串 redisTemplate.setKeySerializer(new StringRedisSerializer()); // 设置值序列化器为 GenericJackson2JsonRedisSerializer，所有的键会被序列化为 Json redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; } } 配置 application.yaml 1 2 3 4 5 6 7 8 9 10 11 12 spring: redis: host: localhost # Redis服务器的主机名，默认 localhost port: 6379 # Redis服务器的端口号，默认 6379 password: # Redis服务器的密码，如果没有密码则留空，默认为空 timeout: 3000 # 连接超时时间（单位：毫秒） lettuce: pool: max-active: 8 # 最大连接数 max-wait: -1 # 最大等待时间，-1表示不限制 max-idle: 8 # 最大空闲连接数 min-idle: 1 # 最小空闲连接数 基本数据结构 String String 是 Redis 中最简单常用的数据类型，可以存储任何类型的数据比如字符串、整形、浮点、序列化后的对象等。\n应用场景 缓存：可以作为缓存数据库使用，提高系统性能，减少对数据库访问的压力。 会话：可以存储 seesion、token，等会话数据，可以用在分布式系统中。 计数器：Redis 的 incr/decr 命令可以用于实现计数器功能。可以将计数器存储为 String 类型，每次更新时通过 incr/decr 命令进行自增或自减操作。 分布式锁：通过 SETNX 命令可以实现一个具有过期时间的分布式锁。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 设置指定 key 值。 SET key value # 获取指定 key 值。 GET key # 判断 key 是否存在。 EXSITS key # 删除 key DEL key # 批量设置 key 值 MSET key1 value1 [key2 value2 ...] # 批量删除 key 值 MGET key1 [ key2 ...] # 将 key 中存储的数值加1。 INCR key # 将 key 中存储的数值减1。 DECR key # 给 key 设置过期时间。 EXPIRE key seconds # 设置 key 值并设置过期时间，如果 key 存在不做任何操作并返回0，否则返回1。 SETNX key value [EX seconds | PX milliseconds] # 查看剩余过期时间。 TTL key Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Test void testString() { // 设置指定 key 值 redisTemplate.opsForValue().set(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;); // 获取指定 key 值 System.out.println(redisTemplate.opsForValue().get(\u0026#34;string1\u0026#34;)); // 判断 key 是否存在 System.out.println(redisTemplate.opsForValue().getOperations().hasKey(\u0026#34;string1\u0026#34;)); // 得到值后删除 key System.out.println(redisTemplate.opsForValue().getAndDelete(\u0026#34;string1\u0026#34;)); // 批量设置 key 值 HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;); map.put(\u0026#34;string2\u0026#34;, \u0026#34;value2\u0026#34;); redisTemplate.opsForValue().multiSet(map); // 批量删除 key 值 HashSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(\u0026#34;string1\u0026#34;); set.add(\u0026#34;string2\u0026#34;); redisTemplate.opsForValue().getOperations().delete(set); // 将 key 中存储的数值加1并返回修改后的值 redisTemplate.opsForValue().set(\u0026#34;num1\u0026#34;, 1); System.out.println(redisTemplate.opsForValue().increment(\u0026#34;num1\u0026#34;)); // 将 key 中存储的数值减1并返回修改后的值 System.out.println(redisTemplate.opsForValue().decrement(\u0026#34;value1\u0026#34;)); // 给 key 设置过期时间 redisTemplate.opsForValue().set(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;); redisTemplate.opsForValue().getAndExpire(\u0026#34;string1\u0026#34;, 1000, TimeUnit.SECONDS); // 设置 key 值并设置过期时间，如果 key 存在不做任何操作并返回 false，否则返回 true System.out.println(redisTemplate.opsForValue().setIfAbsent(\u0026#34;string1\u0026#34;, \u0026#34;value1\u0026#34;)); System.out.println(redisTemplate.opsForValue().setIfAbsent(\u0026#34;string2\u0026#34;, \u0026#34;value2\u0026#34;, 1000, TimeUnit.SECONDS)); // 查看剩余过期时间 System.out.println(redisTemplate.opsForValue().getOperations().getExpire(\u0026#34;string2\u0026#34;)); } List List 是简单的字符串列表，按照插入顺序排序。\n应用场景 最消息排行榜：可以使用 Redis 列表来存储最新的消息。每次有新的消息到达时，将其插入到列表的头，当列表的长度超过一定限制时，可以使用LTRIM命令进行修剪，以保持列表的长度。 实时消息记录：可以使用 Redis 列表来保存实时产生的消息记录。每当有新的消息产生时，将其插入到列表头部，以便可以追溯最近的一定数量的消息记录。 排行榜/计分系统：可以使用 Redis 列表来实现排行榜或计分系统。每个元素可以包含一个分数，通过对元按照分数进行排序，可以获取到排行榜中的前几名或指定范围内的元素。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 将一个或多个值插入到列表的左侧，返回插入后列表的长度。 LPUSH key value [value ...] # 将一个或多个值插入到列表的右侧，返回插入后列表的长度。 RPUSH key value [value ...] #移除返回列表的左侧第一个元素。 LPOP key # 移除并返回列表的右侧第一个元素。 RPOP key # 返回列表的长度。 LLEN key # 获取列表中指定范围内的元素。 LRANGE key start stop # 返回列表中指定索引位置的元素。 LINDEX key index # 设置列表中指定索引位置的元素的值。 LSET key index value # 移除列表中的指定元素。 LREM key count value # 修剪列表，只保留指定范围内的元素。 LTRIM key start stop Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Test void testList() { // 将一个或多个值插入到列表的左侧，返回插入后列表的长度。 redisTemplate.opsForList().leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;, \u0026#34;value3\u0026#34;); // 将一个或多个值插入到列表的右侧，返回插入后列表的长度。 redisTemplate.opsForList().rightPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;value4\u0026#34;, \u0026#34;value5\u0026#34;, \u0026#34;value6\u0026#34;); // 移除返回列表的左侧第一个元素。 System.out.println(redisTemplate.opsForList().leftPop(\u0026#34;mylist\u0026#34;)); // 移除并返回列表的右侧第一个元素。 System.out.println(redisTemplate.opsForList().rightPop(\u0026#34;mylist\u0026#34;)); // 返回列表的长度。 System.out.println(redisTemplate.opsForList().size(\u0026#34;mylist\u0026#34;)); // 获取列表中指定范围内的元素。 System.out.println(redisTemplate.opsForList().range(\u0026#34;mylist\u0026#34;, 2, 3)); // 返回列表中指定索引位置的元素。 System.out.println(redisTemplate.opsForList().index(\u0026#34;mylist\u0026#34;, 3)); // 设置列表中指定索引位置的元素的值。 redisTemplate.opsForList().set(\u0026#34;mylist\u0026#34;, 2, \u0026#34;value3\u0026#34;); // 移除列表中的指定元素。 redisTemplate.opsForList().remove(\u0026#34;mylist\u0026#34;, 1, \u0026#34;value1\u0026#34;); // 修剪列表，只保留指定范围内的元素。 redisTemplate.opsForList().trim(\u0026#34;mylist\u0026#34;, 1, 3); } Hash Hash 是一个 String 类型的键值对。\n应用场景 缓存对象：可以将对象的字段和属性存储在Redis的Hash中，以便快速地读取和更新。例如，用户信息存储在一个Hash中，每个用户的字段可以是用户ID、用户名、年龄等。这样，在需要读取或用户信息时，可以直接通过用户ID来获取或更新相应的字段。 计数器：可以使用Hash来实现计数器功能。通过将计数器的名称作为Hash的键名，将计数值作为键值存储在Hash中。然后可以使用Redis提供的原子操作对计数器进行增减操作，如HINCRBY命令。 实时排行榜：可以使用Hash来实现实时排行榜功能。将用户ID作为Hash的键名，将用户的分数作为键值存储在Hash中。通过更新用户的分数来实现排行榜实时更新，并使用Redis提供的ZSET数据结构进行排名的计算。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 设置 Hash 中指定字段的值。 HSET key field1 value1 [field2 value2...] # 获取 Hash 中指定字段的值 HGET key field # 设置 Hash 中多个字段的值。 HMSET key field1 value1 [field2 value2...] # 获取 Hash 中多个字段的值。 HMGET key field1 [field2...] # 获取 Hash 中所有字段和值。 HGETALL key # 删除 Hash 中的指定字段。 HDEL key field # 判断 Hash 中是否存在指定字段。 HEXISTS key field # 获取 Hash 中所有值 HVALS key Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Test void testHash() { // 设置 Hash 中指定字段的值。 redisTemplate.opsForHash().put(\u0026#34;myhash\u0026#34;, \u0026#34;field1\u0026#34;, \u0026#34;value1\u0026#34;); // 获取 Hash 中指定字段的值 System.out.println(redisTemplate.opsForHash().get(\u0026#34;myhash\u0026#34;, \u0026#34;field1\u0026#34;)); // 设置 Hash 中多个字段的值。 HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;field2\u0026#34;, \u0026#34;value2\u0026#34;); map.put(\u0026#34;field3\u0026#34;, \u0026#34;value3\u0026#34;); redisTemplate.opsForHash().putAll(\u0026#34;myhash\u0026#34;, map); // 获取 Hash 中多个字段的值。 HashSet\u0026lt;Object\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(\u0026#34;field1\u0026#34;); set.add(\u0026#34;field2\u0026#34;); System.out.println(redisTemplate.opsForHash().multiGet(\u0026#34;myhash\u0026#34;, set)); // 获取 Hash 中所有字段和值。 System.out.println(redisTemplate.opsForHash().entries(\u0026#34;myhash\u0026#34;)); // 删除 Hash 中的指定字段。 redisTemplate.opsForHash().delete(\u0026#34;myhash\u0026#34;, \u0026#34;field1\u0026#34;); // 判断 Hash 中是否存在指定字段。 System.out.println(redisTemplate.opsForHash().hasKey(\u0026#34;myhash\u0026#34;,\u0026#34;field2\u0026#34;)); // 获取 Hash 中所有值 System.out.println(redisTemplate.opsForHash().values(\u0026#34;myhash\u0026#34;)); } Set Set 是一种无序集合，集合中的元素唯一，类似于 Java 中的 HashSet\n应用场景 抽奖和排行榜：Set可以用于实现抽奖功能和排行榜功能。例如，抽奖活动的参与者可以存储在Set，每次抽奖时从Set中随机选择一个用户；另外，将用户的得分、点击量或其他指标存储在Set中，可以据权重排序来生成排行榜。 好友关系：Set可以用于存储用户的好友关系。例如，每个用户对应一个Set，保存了该用户的好友列表，可以方便地进行好友操作，如查找共同的好友、计算好友数等。 集成员查找：Redis的Set数据结构可以高效地进行成员的查找操作。例如，可以用于实现黑白名单的判断，快速判断某个元素是否在集合中。 点赞、收藏等功能：可以使用Set来存储用户对某个实体（如文章、评论、商品等）的点赞、收藏关系。个实体的点赞、收藏用户就是一个Set。通过Set提供的添加、删除、计数等操作，可以方便地管理点赞、收藏关系。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 向 Set 中添加一个或多个元素。 SADD key value1 [value2...] # 从 Set 删除一个或多个元素。 SREM key value1 [value2...] # 判断一个元素是否存在于 Set 中。 SISMEMBER key value # 获取 Set 中的所有元素。 SMEMBERS myset # 获取集合的成员数 SCARD key # 移除并返回 Set 中的一个随机元素 SPOP key # 返回所有 Set 的交集 SINTER key1 [key2...] # 返回所有 Set 的并集 SUNION key1 [key2...] # 返回所有 Set 的差集 SDIFF key1 [key2...] Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Test void testSet() { // 向 Set 中添加一个或多个元素。 redisTemplate.opsForSet().add(\u0026#34;myset\u0026#34;, \u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;, \u0026#34;value3\u0026#34;, \u0026#34;value4\u0026#34;); redisTemplate.opsForSet().add(\u0026#34;myset1\u0026#34;, \u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;, \u0026#34;value6\u0026#34;, \u0026#34;value5\u0026#34;); // 从 Set 删除一个或多个元素。 redisTemplate.opsForSet().remove(\u0026#34;myset\u0026#34;, \u0026#34;value3\u0026#34;, \u0026#34;value4\u0026#34;); // 判断一个元素是否存在于 Set 中。 System.out.println(redisTemplate.opsForSet().isMember(\u0026#34;myset\u0026#34;, \u0026#34;value1\u0026#34;)); // 获取 Set 中的所有元素。 System.out.println(redisTemplate.opsForSet().members(\u0026#34;myset\u0026#34;)); // 获取集合的成员数 System.out.println(redisTemplate.opsForSet().size(\u0026#34;myset\u0026#34;)); // 移除并返回 Set 中的一个随机元素 System.out.println(redisTemplate.opsForSet().pop(\u0026#34;myset\u0026#34;)); // 返回所有 Set 的交集 System.out.println(redisTemplate.opsForSet().intersect(\u0026#34;myset\u0026#34;, \u0026#34;myset1\u0026#34;)); // 返回所有 Set 的并集 System.out.println(redisTemplate.opsForSet().union(\u0026#34;myset\u0026#34;, \u0026#34;myset1\u0026#34;)); // 返回所有 Set 的差集 System.out.println(redisTemplate.opsForSet().difference(\u0026#34;myset\u0026#34;, \u0026#34;myset1\u0026#34;)); } Sorted Set Sorted Set 类似于 Set，但和 Set 相比，维护了一个 double 类型的分数，使得集合中的元素能够按分数排列。\n应用场景 排行榜：可以使用Sorted Set来存储用户的得分或其他评分指标，并按照分数进行排序，从而实现排行榜功能。通过Sorted Set提供的操作，如添加成员、更新分数、根据分数范围获取成员等，可以方便地进行排行榜的维护和查询。 积分系统：可以使用Sorted Set来存储用户的积分，并按照积分进行排序。通过Sorted Set提供的操作，如添加成员、更新分数、根据分数范围获取成员等，可以方便地查询用户的排名、前几名用户等功能。 热门文章：可以使用Sorted Set来存储文章以及其阅读量或点赞数等指标，并按照指标进行排序。通过Sorted Set提供的操作，如添加成员、更新分数、根据分数范围获取成员等，可以方便地查询热门文章、热门标签等功能。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 向 Sorted Set 添加一个或多个原素，或者更新已存在元素的分数 ZADD key score1 value1 [score2 value2...] # 获取 Sorted Set 中元素的个数 ZCARD key # 移除 Sorted Set 中一个或多个原素 ZREM key value1 [value2...] # 获取 Sorted Set 中指定元素的分数 ZSCORE key value # 给指定元素添加分数 ZINCRBY key increment value # 根据分数范围获取 Sorted Set 中的元素 ZRANGEBYSCORE key score1 score2 # 通过索引返回 Sorted Set 中指定区间的成员（分数从低到高） ZRANGE key start stop # 通过索引返回 Sorted Set 中指定区间的成员（分数从高到低） ZREVRANGE key start stop # 获取指定元素排名，返回 Sorted Set 中的索引 ZRANK key value # 获取多个 Sorted Set 中的交集并存储在新的 Sorted Set 中 ZINTERSTORE destination numkeys key1 [key2...] # 获取多个 Sorted Set 中的并集并存储在新的 Sorted Set 中 ZUNIONSTORE destination numkeys key1 [key2...] # 获取多个 Sorted Set 中的差集并存储在新的 Sorted Set 中 ZDIFF destination numkeys key1 [key2...] Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Test void testZSet() { // 向 Sorted Set 添加一个或多个原素，或者更新已存在元素的分数 redisTemplate.opsForZSet().add(\u0026#34;myzset\u0026#34;, \u0026#34;value1\u0026#34;, 3.14); redisTemplate.opsForZSet().add(\u0026#34;myzset\u0026#34;, \u0026#34;value2\u0026#34;, 3.141); redisTemplate.opsForZSet().add(\u0026#34;myzset\u0026#34;, \u0026#34;value3\u0026#34;, 3.1415); // 获取 Sorted Set 中元素的个数 System.out.println(redisTemplate.opsForZSet().size(\u0026#34;myzset\u0026#34;)); // 移除 Sorted Set 中一个或多个原素 redisTemplate.opsForZSet().remove(\u0026#34;myzset\u0026#34;, \u0026#34;value3\u0026#34;); // 获取 Sorted Set 中指定元素的分数 System.out.println(redisTemplate.opsForZSet().score(\u0026#34;myzset\u0026#34;, \u0026#34;value1\u0026#34;)); // 给指定元素添加分数 redisTemplate.opsForZSet().incrementScore(\u0026#34;myzset\u0026#34;, \u0026#34;value2\u0026#34;, 1.1); // 根据分数范围获取 Sorted Set 中的元素 System.out.println(redisTemplate.opsForZSet().rangeByScore(\u0026#34;myzset\u0026#34;, 1, 6)); // 通过索引返回 Sorted Set 中指定区间的成员（分数从低到高） System.out.println(redisTemplate.opsForZSet().range(\u0026#34;myzset\u0026#34;, 1, 2)); // 通过索引返回 Sorted Set 中指定区间的成员（分数从高到低） System.out.println(redisTemplate.opsForZSet().reverseRange(\u0026#34;myzset\u0026#34;, 1, 2)); // 获取指定元素排名，返回 Sorted Set 中的索引 System.out.println(redisTemplate.opsForZSet().rank(\u0026#34;myzset\u0026#34;, \u0026#34;value1\u0026#34;)); // 获取多个 Sorted Set 中的交集并存储在新的 Sorted Set 中 redisTemplate.opsForZSet().add(\u0026#34;myzset1\u0026#34;, \u0026#34;value1\u0026#34;, 3.14); redisTemplate.opsForZSet().intersectAndStore(\u0026#34;newzset1\u0026#34;, \u0026#34;myzset1\u0026#34;, \u0026#34;myzset\u0026#34;); // 获取多个 Sorted Set 中的并集并存储在新的 Sorted Set 中 redisTemplate.opsForZSet().unionAndStore(\u0026#34;newzset1\u0026#34;, \u0026#34;myzset1\u0026#34;, \u0026#34;myzset\u0026#34;); // 获取多个 Sorted Set 中的差集并存储在新的 Sorted Set 中 redisTemplate.opsForZSet().differenceAndStore(\u0026#34;newzset1\u0026#34;, Collections.singleton(\u0026#34;myzset1\u0026#34;), \u0026#34;myzset\u0026#34;); } 高级数据结构 Geospatial 应用场景 附近搜索：地理位置服务应用（如打车软件、外卖平台）可以利用 Redis 的地理空间索引来快速找到用户附近的司机或餐馆。 路线规划与距离计算：对于需要进行路径规划或者距离计算的应用程序，如物流配送系统，可以利用GEODIST命令来获取两个地理位置之间的距离。 基于位置的广告推送：零售业可以利用地理信息向顾客推送附近店铺的促销信息。例如，在商场区域内发送优惠券给进入该区域的顾客。 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 添加一个或多个元素对应的经纬度信息到 GEO 中 GEOADD key longitude1 latitude1 member1 [longitude2 latitude2 member2...] # 返回给定元素的经纬度信息 GEOPOS key member1 [member2...] # 计算两个位置之间的距离 GEODIST key member1 member2 [m|km|ft|mi] # 返回一个多多个位置对象的 geohash 值 GEOHASH key member1 [member2...] # 根据给定的经纬度坐标来获取指定范围内的地理位置集合 GEORADIUS key longitude latitude radius [m|km|ft|mi] # 根据存储在位置集合里面的某个地点获取指定范围内的地理位置集合 GEORADIUSBYMEMBER key member radius [m|km|ft|mi] Java 代码测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Test void testGeo() { // 添加一个或多个元素对应的经纬度信息到 GEO 中 redisTemplate.opsForGeo().add(\u0026#34;cities\u0026#34;, new Point(-73.935242, 40.73061), \u0026#34;New York\u0026#34;); redisTemplate.opsForGeo().add(\u0026#34;cities\u0026#34;, new Point(-0.127758, 51.507351), \u0026#34;London\u0026#34;); redisTemplate.opsForGeo().add(\u0026#34;cities\u0026#34;, new Point(116.407526, 39.90403), \u0026#34;Beijing\u0026#34;); // 返回给定元素的经纬度信息 List\u0026lt;Point\u0026gt; position = redisTemplate.opsForGeo().position(\u0026#34;cities\u0026#34;, \u0026#34;New York\u0026#34;, \u0026#34;London\u0026#34;); System.out.println(position); // 计算两个位置之间的距离 Distance distance = redisTemplate.opsForGeo().distance(\u0026#34;cities\u0026#34;, \u0026#34;New York\u0026#34;, \u0026#34;London\u0026#34;, RedisGeoCommands.DistanceUnit.KILOMETERS); System.out.println(distance); System.out.println(distance.getValue()); // 返回一个多多个位置对象的 geohash 值 List\u0026lt;String\u0026gt; hash = redisTemplate.opsForGeo().hash(\u0026#34;cities\u0026#34;, \u0026#34;New York\u0026#34;, \u0026#34;London\u0026#34;); System.out.println(hash); // 根据给定的经纬度坐标来获取指定范围内的地理位置集合 Circle circle = new Circle(-73.935242, 40.73061, Metrics.KILOMETERS.getMultiplier()); RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs() .includeDistance() //包含距离 .includeCoordinates() //包含坐标 .sortAscending() //升序 .limit(50); GeoResults\u0026lt;RedisGeoCommands.GeoLocation\u0026lt;Object\u0026gt;\u0026gt; byxy = redisTemplate.opsForGeo().radius(\u0026#34;cities\u0026#34;, circle, args); byxy.forEach(r -\u0026gt; System.out.println(r)); } ","date":"2024-09-25T18:11:03+08:00","image":"https://limincai.github.io/p/redis-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/redis-quick-start-cover_hu10470396823172311135.jpg","permalink":"https://limincai.github.io/p/redis-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"Redis 快速入门"},{"content":"标题 # 内容为标题，几个#代表几级标题。\n一级标题 二级标题 三级标题 1 2 3 4 5 # 一级标题 ## 二级标题 ### 三级标题 引用块 \u0026gt; 内容为引用块，用于引用内容。\n引用块\n🪆 套娃引用块\n1 2 \u0026gt; 引用块 \u0026gt; \u0026gt;\u0026gt; 🪆 套娃引用块 代码块与代码段 代码块。\n1 代码段 1 2 3 4 5 6 7 `代码块`。 # 其中“java”为代码块语言，可以替换。 ```java System.out.println(\u0026#34;Hello, World!\u0026#34;); ``` 字体样式 斜体 *斜体* 斜体\n粗体 **粗体**\n粗体\n删除线 ~~删除线内容~~\n删除线内容\n下划线 \u0026lt;u\u0026gt;下划线内容\u0026lt;/u\u0026gt;\n下划线内容\n文本高亮 ==内容==\n==内容==\n文本上下标 我是文本^我是上标^\n我是文本我是下标\n1 2 3 我是文本^我是上标^ 我是文本~我是下标~ 分隔符 1 --- 表格 最上一排就是表头，需要在左右使用|表示这是一个表格，同时，下方需要添加分割线，分割线使用-减号表示。\n一 二 三 四 五 1 2 3 4 5 1 2 3 | 一 | 二 | 三 | 四 | 五 | | --- | --- | --- | --- | --- | | 1 | 2 | 3 | 4 | 5 | 其中：\n:--- 为左对齐 :---: 为剧中对齐 ---: 为右对齐 一 二 三 四 五 1 2 3 4 5 1 2 3 | 一 | 二 | 三 | 四 | 五 | | --: | --: | :-: | :-- | :-- | | 1 | 2 | 3 | 4 | 5 | 有序列表 输入当前序号后按退格键（Tab）可以变为子序号。\n一 二 三 四 1 2 3 4 1. 一 1. 二 1. 三 1. 四 无序列表 用法与有序列表类似。\n一 二 三 四 1 2 3 4 - 一 - 二 - 三 - 四 勾选框 我是未完成的任务 我是已完成的任务 1 2 - [ ] 我是未完成的任务 - [x] 我是已完成的任务 图片插入 html 写法 \u0026lt;img src=\u0026quot;图片路径\u0026quot; width=200 heigth=200\u0026gt;\nmarkdown 写法，这种写法无法主动修改图片尺寸。\n![图片描述](图片地址 \u0026quot;图片名称，可选\u0026quot;)\n链接 [链接文本](链接地址)\n有问题请百度\n脚注 java1是世界上最好的语言。\n1 2 java[^1]是世界上最好的语言。 [^1]:世界上最好的语言。 数学公式 公式块 $$ 我是公式 $$ 1 2 3 $$ 我是公式 $$ 如果只想在行内编写，一行内容只需要使用一个美元符囊括即可：\n$ x = 17 + y $\n1 $ x = 17 + y $ 特殊数学符号 代码 符号 描述 \\not= \\= 不等于 \\approx ≈ 约等于 \\times × 乘号 \\div ÷ 除号 \\leq ≤ 小于等于 \\geq ≥ 大于等于 \\pm ± 正负号 \\sum ∑ 求和符号（累加） \\prod ∏ 累乘 \\coprod ∐ 累除 \\overline{a + b + c} a+b+c / 3 平均值 数学中常见特殊字符：\n代码 符号 代码 符号 \\alpha α \\beta β \\gamma γ \\delta δ \\epsilon ϵ \\eta η* \\theta θ \\pi π \\omega ω \\rho ρ \\sigma σ \\mu μ 常见的三角函数：\n代码 符号 描述 \\sin sin 正弦 \\cos cos⁡ 余弦 \\tan tan⁡ 正切 \\cot cot⁡ 余切 \\sec sec⁡ 正割 \\csc csc⁡ 余割 \\circ ∘ 度 积分和求导相关：\n代码 符号 描述 \\infty ∞ 无穷 \\int ∫ 定积分 \\iint ∬ 双重积分 \\iiint ∭ 三重积分 \\oint ∮ 曲线积分 x\\prime x′ 求导 \\lim lim⁡ 极限 集合相关：\n代码 符号 描述 \\emptyset ∅ 空集 \\in ∈ 属于 \\notin ∉ 不属于 \\supset ⊃ 真包含 \\supseteq ⊇ 包含 \\bigcap ⋂ 交集 \\bigcup ⋃ 并集 对数函数相关：\n代码 符号 描述 \\log log⁡ 对数函数 \\ln ln⁡ 以e为底的对数函数 \\lg lg⁡ 以10为底的对数函数 分数 $ \\frac{分子}{分母} $\n$ \\frac{分子}{分母} $\n开方 $\\sqrt{4}$\n$\\sqrt{4}$\n如果需要修改根号上方数值，可以添加中括号。\n$\\sqrt[3]{8}$\n$\\sqrt[3]{8}$\n上下标 ^ 表示上标，_表示下标。\n$ x_下标 $\n$ x^上标 $\n$ x^上标_下标 $\n1 2 3 $ x_下标 $ $ x^上标 $ $ x^上标_下标 $ 如果上标或下标内容多于一个字符，需要使用 {} 括起来，包括后续的其他代码如果出现只有一个字符生效的情况下，考虑使用花括号囊括全部内容：\n$ x*_{下标} $\n$ x^{上标} $\n$ x^{上标}_{下标} $\n1 2 3 $ x_{下标} $ $ x^{上标} $ $ x^{上标}_{下标} $ 积分 `$\\int_积分下限^积分上限xdx $\n$\\int_1^2xdx $\n极限 $ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n + 1} $\n$ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n + 1} $\n其他符号 代码 符号 描述 $ \\vec{a} $ $ \\vec{a} $ 向量符号 $ \\cdots $ $ \\cdots $ 居中省略号 $ \\ldots $ $ \\ldots $ 靠底部的省略号 $ \\cdot $ $ \\cdot $ 点乘号 $ \\sum*_1^n $* $ \\sum_1^n $* 累加 html 标签 markdown 支持 html 标签，可以更加个性化的自定义内容。\n例如：\n1 2 \u0026lt;iframe src=\u0026#34;https://limincai.github.io/\u0026#34; height=\u0026#34;1080\u0026#34; width=\u0026#34;1080\u0026#34; sandbox=\u0026#34;allow-scripts\u0026#34; scrolling=\u0026#34;yes\u0026#34;\u0026gt;\u0026lt;/iframe ","date":"2024-09-22T20:11:03+08:00","image":"https://limincai.github.io/p/markdown-%E8%AF%AD%E6%B3%95/markdown-synatax-cover_hu10298755978458750581.webp","permalink":"https://limincai.github.io/p/markdown-%E8%AF%AD%E6%B3%95/","title":"Markdown 语法"}]